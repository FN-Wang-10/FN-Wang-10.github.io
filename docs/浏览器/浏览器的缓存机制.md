## 为什么要缓存

1. 缓存可以减少用户等待时间，提升用户体验；
2. 减少网络带宽消耗；
   > 对于网站运营者和用户，带宽都代表着成本，过多的带宽消耗，都需要支付额外的费用。如果可以使用缓存，只会产生极 小的网络流量，这将有效的降低运营成本。
3. 降低服务器压力；
   > 给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，降低服务器的压力。此外，搜索引 擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。
   > 注意：缓存使用不当，会有「脏数据」，导致用户数据异常。

常见缓存类型：强缓存、协商缓存。

优先级：两类缓存机制可以同时存在，强缓存的优先级高于协商缓存  
当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行协商缓存  
强缓存不过服务器，协商缓存需要过服务器

判断是强缓存还是协商缓存的方法：根据请求的响应头字段判断（Cache-Control 或者 Expires）

状态码  
强缓存：200  
协商缓存：命中 304，没命中 200，重新返回资源

缓存流程解析

1. 浏览器会先检测强缓存类型（Cache-Control 或者 Expires）是否有效；
2. 如果命中了强缓存，则直接从本地获取缓存资源；
3. 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些 Request Header 验证这个资源是否命中协商缓存，称为 HTTP 再验证，如果命中，服务器将请求返回，返回状态码 304，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
4. 强缓存不会发送请求到服务器，但协商缓存会发送服务器请求；
5. 当协商缓存也没命中时，服务器就会将资源发送回客户端。

需要注意：

1. 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源
2. 当 F5 刷新网页时，跳过强缓存，但是会检查协商缓存；
3. 当 Ctrl + F5 强制刷新页面时，直接从服务器加载，跳过强缓存和协商缓存；

## 一.强缓存

Expires：GMT 格式的时间字符串，代表缓存资源的过期时间

1. Expires 也是需要在服务端配置（具体配置也根据服务器而定），Expires 添加的是该资源过期的日期。浏览器会根据该过期日期与客户端时间对比，如果过期时间还没到，则会去缓存中读取该资源，如果已经到期了，则浏览器判断为该资源已经不新鲜要重新从服务端获取。
2. 通过这种方式，可以实现直接从浏览器缓存中读取，而不需要去服务端判断是否已经缓存，避免了这次 HTTP 请求。值得注意的是 Expires 时间可能存在 客户端时间跟服务端时间不一致 的问题。
3. 建议 Expires 结合 Cache-Control 一起使用，大型网站中一起使用的情况比较多见。
4. Cache-Control: max-age 强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒。
5. Cache-Control 属性值是在 server 端配置的，不同的服务器有不同的配置，web 服务器 apache、nginx、IIS , 应用服务器 tomcat 等配置都不尽相同；

## 二.协商缓存

1. Last-Modified：值为资源最后更新时间，随服务器 Response 返回；
2. If-Modified-Since：通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存。
3. ETag：表示资源内容的唯一标识，随服务器 Response 返回。Web 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识；  
   注：HTTP 中并没有指定如何生成 ETag，哈希是比较理想的选择。  
   If-None-Match：服务器通过比较请求头部的 If-None-Match 与当前资源的 ETag 是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存。

不会缓存的情况  
当然并不是所有请求都能被缓存，无法被浏览器缓存的请求如下：

1. HTTP 信息头中包含 Cache-Control:no-cache ，pragma:no-cache（HTTP1.0），或 Cache-Control: max-age=0 等告诉浏览器不用缓存的请求；
2. 需要根据 Cookie，认证信息等决定输入内容的动态请求是不能被缓存的；
3. 经过 HTTPS 安全加密的请求；
4. POST 请求无法被缓存；
5. HTTP 响应头中不包含 Last-Modified/Etag，也不包含 Cache-Control/Expires 的请求无法被缓存；

上文对整个概念做了阐述，还是不够形象，我们来通过几个小故事生动理解一下：  
故事一：Last-Modified  
浏览器：Hi，我需要 jartto.min.js 这个文件，如果是在 Last-Modified: Fri Feb 15 2019 19:57:31 GMT 之后修改过的，请发给我。  
服务器：（检查文件的修改时间）  
服务器：Oh，这个文件在那个时间之后没有被修改过，你已经有最新的版本了。  
浏览器：太好了，那我就显示给用户了。

故事二：ETag  
浏览器：Hi，我需要 jartto.css 这个文件，有没有不匹配 3c61f-1c1-2aecb436 这个串的  
服务器：（检查 ETag…）  
服务器：Hey，我这里的版本也是 3c61f-1c1-2aecb436，你已经是最新的版本了  
浏览器：好，那就可以使用本地缓存了  
看完这两个小故事，是否对协商缓存有了更清晰的认识了。

强缓存不会向服务器发送请求，直接从缓存中读取资源，在 network 中可以看到状态码为 200  
协商缓存向服务器发送请求，服务器会根据这个请求的 request header 的一些参数来判断是否命中协商缓存，如果命中则返回 304 状态码并带上新的 request header 通知，浏览器从缓存中读取资源  
共同点：都是从客户端缓存中读取资源  
不同点：强缓存不会发请求，协商缓存会发请求

协商缓存可以解决强制缓存情况下资源不更新的问题

时间秒  
哈希值

## 浏览器缓存的原理

当浏览器第一次请求页面资源时，向服务器发送请求，服务器接收到请求返回资源，浏览器会将响应到的资源存贮在浏览器缓存中，当第二次访问该页面资源时就不再向服务器发送请求，直接从浏览器缓存中读取资源

### 浏览器缓存策略

1. **强制缓存**  
   不会向服务器发送请求，直接从浏览器中读取资源，在 chrome 控制台的 network 选项中可以看到该请求返回 200 的状态码
2. **协商缓存**  
   在使用本地缓存之前，需要向服务器发送请求，服务器会根据这个请求的 request header 的一些参数来判断是否命中协商缓存，如果命中则返回 304 状态码并带上新的 request header 通知浏览器从缓存中读取资源，（协商缓存可以解决强制缓存情况下资源不更新的问题\*\*\*\*）
   没有更新返回 304，更新了就重新返回资源并返回 200

这些都是后端设置的

### 强制缓存 header 中的参数（响应头）

**Expires**  
过期时间，如果设置了过期时间，则浏览器会在过期时间内使用缓存。 Expires 是 HTTP1.0 的产物，受限于本地时间，如果认为修改了本地时间，可能会造成缓存失败

**Cache-Control**

1. max-age=31536000 説明是强缓存，表示缓存还可以使用多长时间，是一个相对时间
2. -no-cache 不使用强缓存，而使用协商缓存，先与服务器确认返回的响应是否被更改，如果之前的响应存在 Etag,那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载
3. -no-store 禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源
4. -public 可以被所有的用户缓存，包括中间用户和 CDN 等中间代理服务器
5. -private 只能被终端用户的浏览器缓存，不允许 CDN 等中间缓存服务器对其缓存  
   Expires 设置以分钟为单位的绝对过期时间，设置相对过期时间，max-age 致命以秒为单位的缓存时间
   Expires 的优先级比 Cache-Control 低，同时设置 Expires 和 Cache-Control 则后者生效
   强制缓存有一个问题，当我们从浏览器缓存中读取资源时，万一服务器的资源更新了，就拿不到新的资源

### 协商缓存 header 中的参数（响应头）

设置协商缓存：
**Cache-Control：-no-cache**

**Last-Modify/if-Modify-Since 时间**  
字面理解：当浏览器去向服务器请求数据时，会返回资源，同时在响应头中还会返回 Last-Modify(最新的修改时间，单位是秒)，下一次在请求资源的时候会发一个 if-Modify-Since(只就是上一次的 Last-Modify 时间)，服务器可以拿到最新的修改时间，将两个时间进行对比，如果相同说明资源没有修改过，会返回 304，直接从缓存中取，万一时间不一样，就需要重新返回新的资源，返回 200 状态码
Last-Modify 的值是资源最后修改时间  
这里有个 bug，Last-Modify 最后修改时间是秒为单位，如果服务器中的资源更改是毫秒，资源就不会重新返回

**Etag/if-None-Match hash 值**  
Etag 的值是资源文件对应的 hash 值（会加大服务器开销，hash 值是需要生成的）  
字面理解：当浏览器去向服务器请求数据时，会返回资源，同时在响应头中还会返回 Etag（hash 值），下一次请求的时候会带上 Etag,如果文件被修改了，服务器端判断 Etag 等不等于重新生成的 hash 值，不相等说明文件被修改了，返回新的 Etag 和新资源，返回 200，相等说明没被修改返回 304  
Etag 的值是由文件的索引节点，文件大小，文件最后修改时间进行 hash 之后得到的

Etag 的优先级高于 Last-Modified,服务器会优先验证 Etag

频繁变动的资源建议使用协商缓存  
不经常变动的资源使用强制缓存

参考文献
https://blog.csdn.net/wyouwd1/article/details/123469152?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165778560916781435489480%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165778560916781435489480&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-123469152-null-null.142^v32^pc_rank_34,185^v2^tag_show&utm_term=%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E9%9D%A2%E8%AF%95&spm=1018.2226.3001.4187
