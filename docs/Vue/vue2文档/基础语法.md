## 基础语法

### vue 实例

引入的 Vue 是一个构造函数，里面可以传入一个选项对象

data 里面的内容会向外放一层，直接挂载到实例下面  
只有当实例被创建时就已经存在于 data 中的 property 才是响应式的  
`Object.freeze()`用来冻结数据的  
只能有一个根元素

```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <p>{{ a }}</p>
      <p>{{ obj }}</p>
      <button v-on:click="handleClick">btn</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
      const data = {
        a: 3,
        obj: {
          x: 10,
          y: 20,
          z: null, // 如果想有响应式，需要设置初始值
        },
      };

      // Object.freeze()用来冻结数据的
      // Object.freeze(data);

      const vm = new Vue({
        // data里面的内容会向外放一层，直接挂载到实例下面
        el: "#app",
        data,
        methods: {
          // 只有当实例被创建时就已经存在于 data 中的 property 才是响应式的
          handleClick() {
            // this.obj.y = 30;
            this.obj.z = 30;   // 如果想有响应式，需要设置初始值
          },
        },
      });
    </script>
  </body>
</html>

```

### 简介

项目的最外层只有一个 div
选项式（选项对象）

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <!-- 项目的最外层只有一个div  -->
    <div id="app">
        <!-- 双大括号的模板语法，可以将响应式数据直接渲染到模板里 -->
        <p>{{ msg }}</p>
        <ul>
            <!-- v-for指令，用于循环渲染，这里相当于for...in -->
            <!-- <li v-for="item in list">{{ item }}</li> -->
            <li v-for="item in productsList">
                {{ item.title }}的库存还剩{{ item.count }}件
                <!-- v-if表示条件渲染 -->
                <span v-if="item.count===0">——卖完了</span>
                <span>，单价{{ item.price }}元——————</span>
                <!-- v-on:click表示单击事件-->
                <button v-on:click="item.count++">+</button>
                <button v-on:click="item.count--">-</button>
                <!-- v-model表示双向数据绑定 -->
                <input type="text" v-model="item.count">
                <input type="text" v-model="item.count*item.price">
            </li>
        </ul>
        <p>总数：{{ total }}</p>
        <p>总价: {{ allPrice }}</p>
    </div>



    <!-- 引入Vue -->
    <script src="../../Vue.js"></script>
    <script>
        //引入的Vue是一个构造函数，里面可以传入一个选项对象
        const vm = new Vue({
            //所有的代码都是写在这个对象里面
            //对象的形式是key和value,key称之为options

            //element,意味着vue要去控制这个元素
            el: '#app',
            // data表示响应式数据
            data: {
                msg: "hello vue!",
                list: ["苹果", "香蕉", "橘子", "西瓜"],
                productsList: [{
                    title: "苹果",
                    count: 5,
                    price: 5
                }, {
                    title: "香蕉",
                    count: 20,
                    price: 6
                }, {
                    title: "橘子",
                    count: 10,
                    price: 7
                }, {
                    title: "西瓜",
                    count: 20,
                    price: 8
                }, ]
            },
            //computed表示计算属性 total(总计的意思)，里面写函数，要有return
            computed: {
                total() {
                    return this.productsList.reduce((sum, item) => {
                        return (sum += +item.count);
                    }, 0);
                },
                allPrice() {
                    return this.productsList.reduce((a, item) => {
                        return (a += (+item.price) * item.count);
                    }, 0);
                },
            },

            //表示渲染结束执行，window.onload
            // mounted() {
            //     setTimeout(() => {
            //         this.msg = 'hi';
            //     }, 3000);
            // },
        })
    </script>
</body>

</html>
```

### 声明式渲染`{{}}`

使用双括号的形式进行声明式的渲染，文本  
用双大括号显示的时候，除了 undefined 和 null 以外，都会一字符串的方式显示  
双大括号里面不仅可以使用变量，还可以使用 js 表达式

属性如果要使用变量或者表达式，使用 v-bind 的指令

data 里面的数据是具有响应式的（当这个数据一旦发生改变，页面就会自动的从新渲染）  
在 Vue 里面所有的操作都是在操作数据（再也没有 dom 操作了），数据驱动

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>声明式渲染</title>
</head>

<body>
    <div id="app">
        <!-- 使用双括号的形式进行声明式的渲染，文本 -->
        <!-- 用双大括号显示的时候，除了undefined和null以外，都会一字符串的方式显示 -->
        <!-- 双大括号里面不仅可以使用变量，还可以使用js表达式 -->
        <p>{{ msg }}</p>
        <p>{{ msg.split("").reverse().join("") }}</p>
        <p>{{ count * 2 }}</p>
        <p>{{ done }}</p>
        <p>{{ !done }}</p>
        <p>{{ unf }}</p>
        <p>{{ nl }}</p>
        <p>{{ arr }}</p>
        <p>{{ obj }}</p>

        <hr>

        <!-- 属性如果要使用变量或者表达式，使用v-bind的指令  属性 -->
        <p v-bind:title="title">hello Vue!</p>
        <p v-bind:title="title+1">hello Vue!</p>
        <img v-bind:src="imgUrl" alt="">

    </div>


    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: "#app", //挂载的元素
            // data里面的数据是具有响应式的（当这个数据一旦发生改变，页面就会自动的从新渲染）
            // 在Vue里面所有的操作都是在操作数据（再也没有dom操作了），数据驱动
            data: { //响应式数据
                msg: "hello Vue!",
                count: 2,
                done: true,
                unf: undefined,
                nl: null,
                arr: [1, 2, 3, 4],
                obj: {
                    a: 1,
                    b: 2,
                    c: 3
                },
                title: 123,
                imgUrl: 'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnimg.ws.126.net%2F%3Furl%3Dhttp%3A%2F%2Fdingyue.ws.126.net%2F2021%2F0428%2F8d1df149j00qs9aa4001dc000hs00fym.jpg%26thumbnail%3D650x2147483647%26quality%3D80%26type%3Djpg&refer=http%3A%2F%2Fnimg.ws.126.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1651052104&t=6292c3e9d4635bae81b26af6e28b8571',
            },
        });
    </script>
    <div title="123">hello</div>
</body>

</html>
```

### template

template 就是空的占位符标签，不会显示  
vue 自己提供的一个组件

### key

用 key 管理可复用的元素  
Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，`<input>` 不会被替换掉——仅仅是替换了它的 placeholder  
给元素添加了不同的 key 值，相当于告诉 vue，这两个元素没有关系，不要进行复用

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 用 key 管理可复用的元素 -->
        <!-- Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<input> 不会被替换掉——仅仅是替换了它的 placeholder。 -->

        <!-- 给元素添加了不同的key值，相当于告诉vue，这两个元素没有关系，不要进行复用 -->
        <template v-if="loginType === 'username'">
          <label>Username</label>
          <input placeholder="Enter your username" key='1'>
        </template>
        <template v-else>
          <label>Email</label>
          <input placeholder="Enter your email address" key='0'>
        </template>

        <hr>

        <button @click="loginType = loginType === 'username' ? '123' : 'username'">点击</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                loginType: "username",
            }
        });
    </script>
</body>

</html>
```

### 条件渲染`v-if`

v-if 用于控制一个元素是否渲染  
v-if 里面可以写变量和表达式

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>条件渲染</title>
</head>

<body>
    <div id="app">
        <p>{{ show }}</p>
        <button v-on:click="show=!show">点击</button>
        <!-- v-if用于控制一个元素是否渲染 -->
        <!-- v-if里面可以写变量和表达式 -->
        <p v-if="show===1">现在你看到我了</p>
    </div>


    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: "#app",
            data: {
                // show: false,
                show: 1,
            }
        })
    </script>
</body>

</html>
```

### `v-else` `v-else-if`

v-if 和 v-else 要是并列的兄弟元素

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <h1 v-if="awesome">Vue is awesome!</h1>
        <!-- v-if和v-else要是并列的兄弟元素 -->
        <h1 v-else>Oh no 😢</h1>

        <!-- template就是空的占位符标签，不会显示 -->
        <!-- vue自己提供的一个组件 -->

        <!-- <div v-if="awesome">111</div>
        <div v-if="awesome">222</div>
        <div v-if="awesome">333</div>
        <div v-if="awesome">444</div> -->

        <!-- 满足v-if指令后面的条件则显示template标签里面的内容，不满足则执行v-else指令里面的内容 -->
        <template v-if="show===1">
        <div>111</div>
        <div>111</div>
        <div>111</div>
        <div>111</div>
        </template>
        <!-- 满足v-else-if指令后面的条件，则执行里面的内容 -->
        <template v-else-if="show===2">
        <div>333</div>
        <div>333</div>
        <div>333</div>
        <div>333</div>
        </template>
        <!-- v-else指令上面两个条件都不满足，则执行里面的内容 -->
        <template v-else>
        <div>222</div>
        <div>222</div>
        <div>222</div>
        <div>222</div>
        </template>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                awesome: true,
                show: 20,
            }
        });
    </script>
</body>

</html>
```

### `v-show`

v-show 的语法和 v-if 完全相同  
show 是通过 css 的 display 属性进行切换  
v-if 如果初始化的时候条件为假，则不会进行渲染，直到条件为真才会进行渲染，v-if 是有惰性的  
v-show 初始化的时候已经被渲染，不管条件的真假，它是通过控制元素的 display 属性进行显示的，条件为真则显示，条件为假就不显示

v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。  
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。  
相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。  
一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。

v-show 不能 template 一起用  
v-show 不能和 v-else 以及 v-else-if 一起用

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- v-show的语法和v-if完全相同 -->
        <!-- 区别在于v-show是通过css的display属性进行切换 -->
        <!-- v-if如果初始化的时候条件为假，则不会进行渲染，直到条件为真才会进行渲染，v-if是有惰性的
             v-show初始化的时候已经被渲染，不管条件的真假，它是通过控制元素的display属性进行显示的，条件为真则显示，条件为假就不显示 -->

        <h1 v-if="awesome">Vue is awesome</h1>
        <button @click="awesome=!awesome">点击</button>

        <h1 v-show="awesome1">Vue is awesome</h1>
        <button @click="awesome1=!awesome1">点击</button>
        <!--
        v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。

        v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

        相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

        一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。
       -->
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                awesome: false,
                awesome1: false,
            }
        });
    </script>
</body>

</html>
```

### 列表渲染`v-for`

哪个元素要循环，就给哪个元素添加 v-for

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>列表渲染</title>
</head>

<body>
    <div id="app">
        <!-- v-for指令用于做循环渲染 -->
        <!-- 哪个元素要循环，就给哪个元素添加v-for -->
        <!-- item表示的是每一项，形参 -->
        <ul>
            <li v-for="value in list">{{ value }}</li>
        </ul>

        <hr>

        <p v-for="item in todos">{{ item.text }}</p>
    </div>



    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: "#app",
            data: {
                list: [1, 2, 3, 4],
                todos: [{
                    text: "你好，html"
                }, {
                    text: "你好，css"
                }, {
                    text: "你好，js"
                }, {
                    text: "你好，vue"
                }, ]
            },
        })
    </script>
</body>

</html>
```

### `v-for`遍历数组和对象

v-for 遍历数组时可以接收二个参数（这里的参数都是形参，自定义的，相当于形参）  
第一个参数是：item(数组中的每一项)  
第二个参数：index（每一项所对应的索引）  
for in 循环也可以写成 for of 循环  
在 vue 里 for...in...和 for...of...一样，都可以遍历数组或者对象

遍历对象  
v-for(in&of)遍历对象时，有三个参数  
第一个参数：属性值（value）  
第二个参数：属性名（key  
第三个参数：索引（index）

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- v-for遍历数组时可以接收二个参数（这里的参数都是形参，自定义的，相当于形参）-->
        <!-- 第一个参数是：item(数组中的每一项)， -->
        <!-- 第二个参数：index（每一项所对应的索引） -->
        <!-- for in 循环也可以写成 for of 循环 -->
        <!-- 在vue里for...in...和for...of...一样，都可以遍历数组或者对象 -->

        <!-- 遍历数组 -->
        <Ul>
            <!-- <li v-for="(item,index) in lists">{{ item.message }}-{{ index }}</li> -->
            <li v-for="(item,index) of lists">{{ item.message }}-{{ index }}</li>
        </Ul>

        <hr>

        <!-- 遍历对象 -->
        <!-- v-for(in&of)遍历对象时，有三个参数 -->
        <!-- 第一个参数：属性值（value） -->
        <!-- 第二个参数：属性名（key）-->
        <!-- 第三个参数：索引（index） -->
        <ul>
            <!-- <li v-for="(value,key,index) in object">{{ value }}----{{ key }}----{{ index }}</li> -->
            <li v-for="(value,key,index) of object">{{ value }}----{{ key }}----{{ index }}</li>
        </ul>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                lists: [{
                    message: "Foo"
                }, {
                    message: "Bar"
                }],
                object: {
                    title: "How to do lists in Vue",
                    author: "Jane Doe",
                    publishedAt: "2016-04-10",
                },
            }
        });
    </script>
</body>

</html>
```

### 循环嵌套，在 v-for 里使用范围值

```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <div v-for="item in sets">
        <div v-for="val in item">{{ val }}</div>
      </div>

      <span v-for="n in 10">{{ n }} </span>

      <div v-for="item in 9">
        <span v-for="value in item">
          {{ value }} * {{ item }} = {{ value * item }}
        </span>
      </div>
    </div>

    <script src="../../Vue.js"></script>
    <script>
      new Vue({
        el: "#app",
        data: {
          sets: [
            [1, 2, 3, 4, 5],
            [6, 7, 8, 9, 10],
          ],
        },
      });
    </script>
  </body>
</html>

```

### v-if 和 v-for 不要一起使用

一个元素同时有 v-for 和 v-if, v-for 会有一个更高的优先级

判断条件和 item 相关的时候，可以使用计算属性来过滤  
判断条件和 item 无关的时候，可以把 v-if 放到父元素

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 一个元素同时有v-for和v-if, v-for会有一个更高的优先级 -->

        <!-- 这种会有性能损耗 -->
        <ul>
            <!-- 判断条件和item相关的时候，可以使用计算属性来过滤 -->
            <li v-for="(item,index) in list" :key="index" v-if="item%2">{{ item }}</li>
        </ul>

        <!-- 利用计算属性，先对数据进行过滤，过滤完之后再进行循环 -->
        <ul>
            <li v-for="(item,index) in oddList" :key="index" v-if="item%2">{{ item }}</li>
        </ul>

        <!-- 这种方法，添加一个show变量，对show进行判断，如果为true就进行循环，如果为false则不会进行循环 -->
        <ul>
            <li v-for="(item,index) in newList" :key="index">{{ item }}</li>
        </ul>

        <!-- 判断条件和item无关的时候，可以把v-if放到父元素 -->
        <ul v-if="show">
            <li v-for="(item,index) in list" :key="index">{{ item }}</li>
        </ul>


    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                list: [1, 2, 3, 4, 5, 6, 7],
                show: true,
            },
            computed: {
                oddList() {
                    return this.list.filter(item => item % 2);
                },
                newList() {
                    if (this.show) {
                        return this.list;
                    } else {
                        return [];
                    }
                }
            },
        });
    </script>
</body>

</html>
```

### 循环中的 key

key 保证如果改变前后的两个元素的 key 是相同的，就会直接复用，提高性能  
key 必须保证不重复, key 必须是数字或者字符串  
只要使用 v-for 循环，就必须加:key=""（无脑加）,最好的用 id,如果没有 id 才用 index
key 的值不可以是引用类型（复杂类型）的，因为引用类型比较的是地址，改变前和改变后对象的值地址肯定是不相同的，

vue 在使用 v-for 循环的时候，如果我们要在数组或者对象中添加或者修改内容，vue 会从新进行渲染（卸载和重新创建），其实我们只是在原数组或者对象中添加一项，前面的几项还是一样的，但是 vue 也会重新渲染（卸载并重新创建），这样就会造成性能损耗，浪费资源。因此我们需要在循环的元素中添加一个 key（key 必选保证不重复，同时 key 必须是数字或者字符串），渲染的每一个元素的 key 都是不相同的，这样可以让 vue 进行判断，如果再次渲染和渲染前元素的 key 相同，就不会进行渲染就可以复用，只会渲染 key 值不相同的元素，可以提升性能

尽量不要使用 index 作为 key，实在没办法才使用 index 作为 key(因为如果在数组中插入一项，那么原有的数组项的 index 会改变，key 值就不相同了，vue 就无法进行复用，只能重新卸卸载并创建)

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- key保证如果改变前后的两个元素的key是相同的，就会直接复用，提高性能 -->
        <!-- key必须保证不重复, key必须是数字或者字符串 -->
        <!-- 只要使用v-for循环，就必须加:key=""（无脑加）,最好的用id,如果没有id才用index-->
        <!-- key的值不可以是引用类型（复杂类型）的，因为引用类型比较的是地址，改变前和改变后对象的值地址肯定是不相同的， -->
        <!-- vue在使用v-for循环的时候，如果我们要在数组或者对象中添加或者修改内容，vue会从新进行渲染（卸载和重新创建），其实我们只是在原数组或者对象中添加一项，前面的几项还是一样的，但是vue也会重新渲染（卸载并重新创建），这样就会造成性能损耗，浪费资源。因此我们需要在循环的元素中添加一个key（key必选保证不重复，同时key必须是数字或者字符串），渲染的每一个元素的key都是不相同的，这样可以让vue进行判断，如果再次渲染和渲染前元素的key相同，就不会进行渲染就可以复用，只会渲染key值不相同的元素，可以提升性能 -->

        <!-- 尽量不要使用index作为key，实在没办法才使用index作为key(因为如果在数组中插入一项，那么原有的数组项的index会改变，key值就不相同了，vue就无法进行复用，只能重新卸卸载并创建) -->
        <ul>
            <li v-for="(item,index) in list" :key="item.id">{{ item.message }}</li>
        </ul>
        <button @click="fn">点击</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                list: [{
                    message: "Foo",
                    id: 1
                }, {
                    message: "Bar",
                    id: 2
                }, ],
                arr: [1, 2, 3, 3, 3],
            },
            methods: {
                fn() {
                    this.list.push({
                        message: 'zoo',
                        id: 3,
                    });
                },
            },
        });
    </script>
</body>

</html>
```

### 数组的检测更新

#### 响应式失效

1. 直接改变数组长度
2. 通过索引去改变数组项
3. 在对象里面挂载新属性

解决(依靠 es5 的浅拷贝，将原来的数组的长度变为 3，通过扩展运算符展开这个数组，放入一个新数组，重新赋值给这个数组，利用的是浅拷贝)

`...` `concat` `Object.assign`

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <ul>
            <li v-for="(item,index) in list" :key="index">{{ item }}</li>
        </ul>
        <p>{{ obj }}</p>
        <button @click="handleClick">点击</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                list: [1, 2, 3, 4, 5],
                obj: {
                    a: 3,
                    b: 4,
                },
            },
            methods: {
                handleClick() {
                    // this.list.push(6);
                    //响应式失效
                    // 1. 直接改变数组长度
                    // 2. 通过索引去改变数组项
                    // 3. 在对象里面挂载新属性

                    this.list.length = 3; //响应式失效
                    // this.list[2] = 20;//响应式失效
                    // this.obj.a = 10;//正常
                    this.obj.c = 100; //响应式失效

                    // 解决(依靠es5的浅拷贝，将原来的数组的长度变为3，通过扩展运算符展开这个数组，放入一个新数组，重新赋值给这个数组，利用的是浅拷贝)
                    //方法1
                    this.list = [...this.list];
                    // this.list[2]=20;
                    // console.log(this.list);
                    //方法2
                    this.list = [].concat(this.list);
                    //方法1
                    // this.obj = {...this.obj
                    // };
                    //方法2
                    this.obj = Object.assign({}, this.obj);
                },
            },
        });
    </script>
</body>

</html>
```

### 事件`v-on`

调用事件处理函数时，小括号可以加，也可以不加  
加上括号可以做事件的传参  
如果只获取事件对象，不传实参，不用加括号，否则就获取不到事件对象（会输出 undefined）  
如果需要传参，同时需要获取事件对象，则把事件对象写在后面$event

v-on 可以缩写成@

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>事件</title>
</head>

<body>
    <div id="app">
        <!-- v-on指令用于定义事件 -->
        <button v-on:click="handleClick">点击1</button>
        <hr>
        <p>{{ count }}</p>
        <!-- <button v-on:click="count++">count++</button> -->
        <!-- 调用事件处理函数时，小括号可以加，也可以不加 -->
        <!-- 加上括号可以做事件的传参 -->
        <!-- 如果只获取事件对象，不传实参，不用加括号，否则就获取不到事件对象（会输出undefined） -->
        <button v-on:click="countAdd(2)">点击+2</button>
        <button v-on:click="countAdd(3)">点击+3</button>
        <hr>
        <!-- 如果需要传参，同时需要获取事件对象，则把事件对象写在后面$event -->
        <button v-on:click="fn()">点击2</button>
        <button v-on:click="fn2(3,$event)">点击3</button>
        <hr>
        <input type="text" v-on:input="handleInput">
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: "#app",
            data: {
                count: 1,
            },
            // methods选项就是定义事件处理函数的地方
            methods: {
                handleClick() {
                    console.log(1);
                },
                countAdd(num) {
                    this.count += num;
                },
                fn(e) {
                    console.log(e); //undefined 打印事件对象
                },
                fn2(num, e) {
                    console.log(num);
                    console.log(e);
                },
                handleInput(e) {
                    console.log("input的值改变了");
                    console.log(e.target);
                    console.log(e.target.value);
                }
            },
        })
    </script>
</body>

</html>
```

### 双向绑定`v-model`

双向绑定必须是和表单元素相关的  
v-model 指令可以用于双向数据绑定，input 和 data 里面的响应式数据进行绑定  
v-model 只是一个语法糖 v-model 加在 input 中  
v-model 其实就是 v-bind 和 v-on 的语法糖

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>双向绑定</title>
</head>

<body>
    <div id="app">
        <!-- 双向绑定必须是和表单元素相关的 -->
        <!-- v-model指令可以用于双向数据绑定，input和data里面的响应式数据进行绑定 -->
        <!-- v-model只是一个语法糖 v-model加在input中 -->
        <!-- v-model其实就是v-bind和v-on的语法糖 -->

        <input type="text" v-model="msg">
        <p>{{ msg }}</p>
        <button v-on:click="handleClick">点击</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: "#app",
            data: {
                msg: 'hello vue',
            },
            methods: {
                handleClick() {
                    this.msg = 'hi';
                },
            },
        });
    </script>
</body>

</html>
```

### 双向绑定(手动实现)

v-model 其实就是 v-bind 和 v-on 的语法糖

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>手动实现</title>
</head>

<body>
    <div id="app">
        <!-- v-model其实就是v-bind和v-on的语法糖 -->
        <input type="text" v-bind:value="msg" v-on:input="handleInput">
        <p>{{ msg }}</p>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                msg: 'hello vue',
            },

            methods: {
                handleInput(e) {
                    this.msg = e.target.value;
                },
            },
        });
    </script>
</body>

</html>
```

### TODOLIST 案例

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>发布案例</title>
</head>

<body>
    <div id="app">
        <input type="text" v-model="textValue">
        <button v-on:click="add">添加</button>

        <ul>
            <li v-for="value in list">{{ value }}————
                <button v-on:click="remove(value)">删除</button>
            </li>
        </ul>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: "#app",
            data: {
                list: ['你好，世界', '你好,html'],
                textValue: "",
            },
            methods: {
                add() {
                    this.list.push(this.textValue);
                    this.textValue = "";
                },
                remove(v) {
                    this.list = this.list.filter(value => value !== v);
                    // this.list = this.list.filter((value) => {
                    //     return value !== v;
                    // });
                },
            },
        });
    </script>
</body>

</html>
```

## 模板语法

### 插值`v-once`

v-once 指令表示这个元素只会被渲染一次

### 原始 HTML`v-html`

v-html 指令可以将内容转成 html 标签进行渲染

### 原始普通文本`v-text`

v-text 指令和双大括号一样渲染普通文本

### 属性`v-bind`

v-bind 指令可以将数据绑定到属性上，缩写成：

```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <h3>模板语法</h3>
      <!-- v-once指令表示这个元素只会被渲染一次 -->
      <p v-once>{{ count }}</p>
      <p>{{ count }}</p>
      <button @click="count++">btn</button>

      <hr />

      <!-- v-html指令可以将内容转成html标签进行渲染 -->
      <div>{{ content }}</div>
      <div v-html="content"></div>
      <!-- v-text指令和双大括号一样渲染普通文本 -->
      <div v-text="content"></div>

      <hr />

{/* 动态参数 */}
      <img :[str]="imgUrl" alt="" />
    </div>

    <script src="../../Vue.js"></script>
    <script>
      new Vue({
        el: "#app",
        data: {
          count: 1,
          content: "<h1>标题</h1>",
          str: "data-src",
          imgUrl:
            "https://img2.baidu.com/it/u=839977396,1548112407&fm=253&fmt=auto&app=138&f=JPEG?w=554&h=500",
        },
        mounted() {
          setTimeout(() => {
            this.str = "src";
          }, 2000);
        },
      });
    </script>
  </body>
</html>

```

## 计算属性(computed)

计算属性(看似是个函数，可以把他当做属性看)  
里面写的是函数，里面的函数必须要有返回值  
计算属性是不改变原始数据的（就是 data 里面的响应式数据），原始数据还是原样，可以使用  
计算属性是有缓存的，缓存的是函数的返回值，只有当依赖发生改变的时候才会再次计算  
计算属性需要有依赖，响应式数据就是它的依赖  
计算属性里面的函数一开始就会先执行（计算属性里面的函数只要有依赖，它就会先执行好，然后存储下来，函数所依赖的响应式数据只要发生改变，计算属性就会从新计算，并从新保存,用的时候当做属性使用，不用去调用）  
一个计算属性可以同时依赖多个响应式数据，还可以依赖其它的计算属性  
不能直接修改计算属性，改变计算属性唯一的方式就是修改它的依赖（依赖的响应式数据）

计算属性什么时候使用  
我们要通过现有的响应式数据，计算出或者说过滤出一个新的值的时候，并且要不改变响应式数据，可以使用计算属性

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- <p>{{ msg.split("").reverse().join("") }}</p>
        <p>{{ msg.split("").reverse().join("") }}</p>
        <p>{{ msg.split("").reverse().join("") }}</p> -->

        <!-- <p>{{ reverseMsg() }}</p>
        <p>{{ reverseMsg() }}</p>
        <p>{{ reverseMsg() }}</p> -->

        <p>{{ msg }}</p>
        <p>{{ reverseMsg }}</p>
        <p>{{ reverseMsg }}</p>
        <p>{{ reverseMsg }}</p>
        <button @click="handleClick">点击</button>

        <ul>
            <li v-for="item in doubleOddArr">{{ item }}</li>
        </ul>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                msg: 'hello vue!',
                count: 5,
                arr: [1, 2, 3, 4, 5, 6],
            },
            methods: {
                // reverseMsg() {
                //     console.log(1);
                //     return this.msg.split("").reverse().join("");
                // },
                handleClick() {
                    this.msg = this.msg + 5;
                    this.arr.push(7);
                    this.reverseMsg = 'hi'; //报错  不能直接修改计算属性
                }
            },
            //计算属性(看似是个函数，可以把他当做属性看)
            //里面写的是函数，里面的函数必须要有返回值
            // 计算属性是不改变原始数据的（就是data里面的响应式数据），原始数据还是原样，可以使用
            //计算属性是有缓存的，缓存的是函数的返回值，只有当依赖发生改变的时候才会再次计算
            //计算属性需要有依赖，响应式数据就是它的依赖
            //计算属性里面的函数一开始就会先执行（计算属性里面的函数只要有依赖，它就会先执行好，然后存储下来，函数所依赖的响应式数据只要发生改变，计算属性就会从新计算，并从新保存,用的时候当做属性使用，不用去调用）
            // 一个计算属性可以同时依赖多个响应式数据，还可以依赖其它的计算属性
            // 不能直接修改计算属性，改变计算属性唯一的方式就是修改它的依赖（依赖的响应式数据）

            // 计算属性什么时候使用
            // 我们要通过现有的响应式数据，计算出或者说过滤出一个新的值的时候，并且要不改变响应式数据，可以使用计算属性
            computed: {
                reverseMsg() {
                    console.log(1);
                    return this.msg.split("").reverse().join("") + this.count; //一个计算属性可以同时依赖多个响应式数据
                },
                oddArr() {
                    return this.arr.filter(item => item % 2 === 1);
                },
                doubleOddArr() {
                    return [...this.oddArr, ...this.oddArr]; //还可以依赖其它的计算属性
                },
            }
        });
    </script>
</body>

</html>
```

## 侦听属性(watch)

监听响应式数据，里面写函数，函数的名称就是要监听的响应式数据（也就是变量）

监听对象

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <p>{{ count }}</p>
        <button @click="count++">点击</button>

        <hr>

        <p>{{ obj.a }}</p>
        <button @click="obj.a=40">点击</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                count: 1,
                obj: {
                    a: 4,
                    b: 5,
                },
            },
            //watch用于监听
            // 监听响应式数据，里面写函数，函数的名称就是要监听的响应式数据（也就是变量）
            watch: {
                //监听count这个变量
                count(val, oldVal) { //val:新值  oldVal:旧值
                    console.log(1);
                    console.log(val);
                    console.log(oldVal);
                },
                //监听obj这个对象
                // obj(val) {
                //     console.log(val); //打印不出来结果，因为obj是引用类型的数据，监听的是地址，只要地址不发生改变，旧监听不到，而我们要监听的是obj对象里面的a的值，所以不能这样写
                // },
                obj: {
                    handler(val) {
                        console.log(val);
                    },
                    // 深度监听，可以监听对象和数组
                    deep: true,
                    // 进入页面的时候就会先做一次监听
                    immediate: true,
                },

            }
        });
    </script>
</body>

</html>
```

## 计算属性 vs 侦听属性

计算属性是依赖的响应式数据发生改变的时候执行，得到一个新的值（被动），这个属性会在模板中使用的  
侦听属性是自己的这个变量改变了，从而去触发这个函数（主动）  
计算属性可以同时依赖多个响应式数据，还可以依赖其它的计算属性，侦听属性只能一个一个去侦听  
一般情况下更加推荐使用计算属性  
当执行异步或开销较大的操作时，使用 watch

```javascript

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <input type="text" v-model="firstName">
        <br>
        <input type="text" v-model="lastName">
        <br>
        <p>{{ fullName }}</p>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                firstName: '李',
                lastName: '四',
                fullName: '李 四',
            },
            // 监听属性实现
            watch: {
                firstName(val) {
                    this.fullName = val + '' + this.lastName;
                },
                lastName(val) {
                    this.fullName = this.firstName + '' + val;
                },
            },
            // 计算属性实现
            // computed: {
            //     fullName() {
            //         return this.firstName + '' + this.lastName;
            //     },
            // },
        });
    </script>

</body>

</html>
```

## 组件

创建组件有两种方式

- 全局组件
- 局部组件

### 全局组件

里面有两个参数，第一个参数是组件名称，第二个参数是选项对象  
这个对象里面写的是 option，new Vue 可以写什么，这里就可以写什么，除了 el  
里面必须要有一个东西叫 template

#### 组件的取名规则

- 顾名思义(语义化)
- 不能和现有的 h5 标签重复
- 取名要使用连字符或者大驼峰
- 使用的时候要使用连字符

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>组件</title>
</head>

<body>
    <div id="app">
        <tbheader></tbheader>
        <tbheader></tbheader>

        <tbbody></tbbody>
        <tbbody></tbbody>
        <tbbody></tbbody>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        //创建组件有两种方式

        //全局创建组件
        //里面有两个参数，第一个参数是组件名称，第二个参数是选项对象
        Vue.component('tbheader', {
            // 这个对象里面写的是option，new Vue可以写什么，这里就可以写什么，除了el
            // 里面必须要有一个东西叫template
            template: '<header>淘宝头部</header>'
        });

        Vue.component('tbbody', {
            // 组件里面的data要使用函数的方式
            data() {
                return {
                    count: 123,
                };
            },
            template: `
                <main>{{ count }}</main>
            `,
        })

        /*
        组件的取名规则
          顾名思义(语义化)
          不能和现有的h5标签重复
          取名要使用连字符或者大驼峰
          使用的时候要使用连字符
      */
        new Vue({
            el: "#app",
        })
    </script>
</body>

</html>
```

### 局部组件

对象里面写的还是选项，跟全局创建组件的第二个参数完全相同  
取名只能使用大驼峰了,使用只能用连字符  
局部创建的组件是需要注册的(在 components 中)

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <tb-header></tb-header>
        <tb-footer></tb-footer>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        // 局部创建组件
        // 对象里面写的还是选项，跟全局创建组件的第二个参数完全相同

        // 取名只能使用大驼峰了,使用只能用连字符
        const TbHeader = {
            template: `<div>淘宝头部</div>`,
        };
        const TbButton = {
            template: `<button>按钮</button>`,
        };

        //组件的嵌套
        const TbFooter = {
            data() {
                return {
                    msg: '底部',
                };
            },
            template: `<footer>淘宝{{ msg }}---<tb-button></tb-button></footer>`,
            components: {
                TbButton,
            }
        }


        new Vue({
            el: '#app',
            data: {},
            //局部创建的组件是需要注册的
            components: {
                TbHeader,
                TbFooter,
            }
        });
    </script>
</body>

</html>
```

### 局部注册组件(components)

局部创建的组件需要注册  
谁使用这个组件，就在谁里面注册，同时组件的标签就写注册的模板中,项目最外层的组件要在根组件里注册，使用的时候要在根标签里使用  
最大的组件要定义在最下面

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <maoyan></maoyan>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        // 局部创建的组件需要注册
        // 谁使用这个组件，就在谁里面注册，同时组件的标签就写注册的模板中,项目最外层的组件要在根组件里注册，使用的时候要在根标签里使用
        // 最大的组件要定义在最下面

        // 猫眼头部组件
        const MaoyanHeader = {
            template: `
                <header>猫眼头部</header>
            `,
        };
        // 猫眼内容组件
        const MaoyanMain = {
            template: `
                <main>猫眼内容</main>
            `,
        };
        // 猫眼底部组件
        const MaoyanFooter = {
            template: `
                <footer>猫眼底部</footer>
            `,
        };
        // 猫眼项目大组件
        const Maoyan = {
            template: `
                <div>
                    <maoyan-header></maoyan-header>
                    <maoyan-main></maoyan-main>
                    <maoyan-footer></maoyan-footer>
                </div>
            `,
            components: {
                MaoyanHeader,
                MaoyanMain,
                MaoyanFooter,
            }
        };
        new Vue({
            el: '#app',
            data: {},
            components: {
                Maoyan,
            }
        });
    </script>
</body>

</html>
```

### 组件基础

组件的 data 必须要写成函数返回对象  
是因为函数有作用域，可以让我们的组件维护自己的状态(data 的数据)  
如果组件里的 data 直接写成对象，那么 data 里面的变量就会变成全局的，复用的时候就会影响到别的组件，函数有作用域，函数返回对象实际上和直接写对象是一样的，但是可以自己维护自己的数据，不会影响到别的组件

每一个组件必须只能有一个根元素，需要在外面加一个标签

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <button-counter></button-counter>
        <button-counter></button-counter>
        <button-counter></button-counter>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        Vue.component('button-counter', {
            // 组件的data必须要写成函数返回对象
            // 是因为函数有作用域，可以让我们的组件维护自己的状态(data的数据)
            // 如果组件里的data直接写成对象，那么data里面的变量就会变成全局的，复用的时候就会影响到别的组件，函数有作用域，函数返回对象实际上和直接写对象是一样的，但是可以自己维护自己的数据，不会影响到别的组件

            // 每一个组件必须只能有一个根元素，需要在外面加一个标签
            // template在这里用不了
            data() {
                return {
                    count: 0,
                };
            },
            template: `
                <div>
                    <button @click="handleClick">点击++</button>
                    <p>点击了{{ count }}次</p>
                </div>
            `,
            methods: {
                handleClick() {
                    this.count++;
                }
            }
        })
        new Vue({
            el: '#app',
            data: {}
        });
    </script>
</body>

</html>
```

### 微博发布案例

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        header {
            width: 100%;
            height: 60px;
            background: lightcoral;
            font-size: 20px;
            text-align: center;
            line-height: 60px;
        }

        .item {
            width: 335px;
            height: 100px;
            border: 1px solid #000;
            margin: 20px;
        }

        footer {
            width: 100%;
            height: 50px;
            background: lightpink;
            position: fixed;
            left: 0;
            bottom: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
        }

        textarea {
            width: 260px;
        }

        .release {
            width: 50px;
            height: 30px;
        }
    </style>
</head>

<body>
    <div id="app">
        <w-blog></w-blog>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        //整个页面的大组件
        Vue.component('w-blog', {
            // 祖先元素往下传
            data() {
                return {
                    size: 0,
                    blogList: [{
                        id: 1,
                        title: "9天！沈阳方舱医院一期完工",
                        content: "辽宁省沈阳市方舱医院应急改造一期工程顺利完工，正式具备交付使用条件。",
                    }, {
                        id: 2,
                        title: "美为何“独家反对”生物武器核查机制",
                        content: "美国为一己私利在俄罗斯和乌克兰之间点燃战火",
                    }, {
                        id: 3,
                        title: "在褒扬烈士中汇聚浩荡英雄气",
                        content: "彰显了新时代党和国家对英雄烈士荣誉地位的崇高标定。",
                    }, ],
                };
            },
            template: `
                <div :style="{'font-size':size + 'px'}">
                    <blog-header @sizeToBig="handleSizeToBig"></blog-header>
                    <blog-content :list="blogList"></blog-content>
                    <blog-footer></blog-footer>
                </div>
            `,
            methods: {
                handleSizeToBig(size) {
                    // console.log(1);
                    this.size = size;
                }
            }
        });

        // 微博头部组件
        Vue.component('blog-header', {
            data() {
                return {
                    size: 16,
                }
            },
            template: `
                <header>微博头部
                    <button @click="handleClick">点击字体++</button>
                </header>
            `,
            mounted() {
                // 页面刚渲染染成就传一次数据
                this.$emit("sizeToBig", this.size);
            },
            methods: {
                handleClick() {
                    this.size++;
                    this.$emit("sizeToBig", this.size);
                }
            }
        });

        // 微博内容组件
        Vue.component('blog-content', {
            //父传子
            // data() {
            //     return {
            //         blogList: [{
            //             id: 1,
            //             title: "9天！沈阳方舱医院一期完工",
            //             content: "辽宁省沈阳市方舱医院应急改造一期工程顺利完工，正式具备交付使用条件。",
            //         }, {
            //             id: 2,
            //             title: "美为何“独家反对”生物武器核查机制",
            //             content: "美国为一己私利在俄罗斯和乌克兰之间点燃战火",
            //         }, {
            //             id: 3,
            //             title: "在褒扬烈士中汇聚浩荡英雄气",
            //             content: "彰显了新时代党和国家对英雄烈士荣誉地位的崇高标定。",
            //         }, ],
            //     };
            // },
            props: ["list"], //接受祖先元素传的数据
            template: `
                <main>
                    <blog-content-item v-for="item in list" :key="item.id" :title="item.title" :content="item.content"></blog-content-item>

                </main>
            `,
        });

        // 内容item组件
        Vue.component('blog-content-item', {
            props: ["title", "content"], //接收父元素传入的数据
            template: `
                <div class="item">
                    <h3>{{ title }}</h3>
                    <p>{{ content }}</p>
                    <blog-button buttonValue="点赞"></blog-button>
                </div>
            `,

        })

        // 微博底部组件
        Vue.component('blog-footer', {
            template: `
                <footer>
                    <textarea></textarea>
                    <blog-button buttonValue="发布"></blog-button>
                </footer>
            `,
        });

        // 微博按钮组件
        Vue.component("blog-button", {
            props: ["buttonValue"], //接收父元素传入的数据
            template: `
                <button>{{ buttonValue }}</button>
            `,
        });

        new Vue({
            el: '#app',
            data: {}
        });
    </script>
</body>

</html>
```

### 父传子(props []接收)

自定义属性后面的值，如果是变量或者表达式，需要使用 v-bind

父传子

1. 需要在父组件的子组件的标签上添加自定义属性
2. 在子组件里面使用 props 选项进行接收（数组的形式，数组里面的数组项需要带引号）  
   总结：可以父传子，也可以祖先传子

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <div>父组件</div>
        <!-- 自定义属性后面的值，如果是变量或者表达式，需要使用v-bind -->
        <child abc="10" name="zhansan" :count="count"></child>

        <!-- 组件可以进行v-for循环的 -->
        <child2 v-for="item in list" :key="item.id" :name="item.name"></child2>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        // 父传子
        // 1.需要在父组件的子组件的标签上添加自定义属性
        // 2.在子组件里面使用props选项进行接收（数组的形式，数组里面的数组项需要带引号）
        // 总结：可以父传子，也可以祖先传子
        Vue.component('child', {
            template: `
                <div>child组件 {{ abc }} {{ name }} {{ count }}</div>
            `,
            props: ["abc", "name", "count"],
        });


        Vue.component('child2', {
            props: ["name"],
            template: `
                <div>child组件--{{ name }}</div>
            `,

        });


        new Vue({
            el: '#app',
            data: {
                count: 20,
                list: [{
                    id: 1,
                    name: "zhangsan",
                }, {
                    id: 2,
                    name: "lisi",
                }, {
                    id: 3,
                    name: "wangwu",
                }, ],
            },
        });
    </script>
</body>

</html>
```

### props(对象接收)

props 除了用数组接受以外，还可以使用对象的方式进行接收

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <h3>props</h3>
        <!-- 如果想传递一个数字，前面需要加上v-bind -->
        <!-- <child name="zhangsan" :age-count="18"></child> -->
        <child :obj="obj"></child>
    </div>


    <script src="../../Vue.js"></script>
    <script>
        // 自定义属性的规范
        // 传递：连字符
        // 接收：小驼峰
        const child = {
            // props: ["name", "ageCount"],
            // props除了用数组接受以外，还可以使用对象的方式进行接收
            // props: {
            //     name: String,
            //     ageCount: Number,
            // },
            props: {
                obj: Object,
            },
            template: `
                <div>
                    <div>{{ obj.name }}的年龄是{{ obj.age }}岁</div>
                </div>
            `,
        }
        new Vue({
            el: '#app',
            data: {
                // count:23
                obj: {
                    name: 'zhangsan',
                    age: 23,
                },
            },
            components: {
                child,
            }
        });
    </script>
</body>

</html>
```

### props 的验证

如果传的自定义属性，在子组件没有用 props 接受，那么它就会直接挂载到子组件的根元素上面

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <h3>prop验证</h3>
        <!-- 如果传的自定义属性，在子组件没有用props接受，那么它就会直接挂载到子组件的根元素上面 -->
        <child name="张三" :age="23" :sex="1" :money="15000" color="red" :height="180" abc="123"></child>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        const Child = {
            props: {
                name: String, //String是规定类型，上面不传也不会报错
                // 多个类型,可以不传，不会报错
                age: [Number, String],
                // 必填，不可以不传
                sex: {
                    type: [String, Number],
                    required: true, //必填
                },
                // 有默认值,可以不传
                money: {
                    type: Number,
                    default: 3500,
                },
                // 自定义验证函数
                color: {
                    type: String,
                    validator(value) {
                        // 这个值必须匹配下列字符串中的一个
                        return ["red", "yellow"].indexOf(value) !== -1;
                    },
                },
                height: {
                    type: Number,
                    validator(value) {
                        return value > 100;
                    },
                },
                // xxx:{
                //     validator(value){
                //         const reg=/ /;//正则表达式
                //         return reg.test();
                //     },
                // }

            },
            template: `
                <div :style="{color:color}">{{ name }}的年龄是{{ age }}岁,性别{{ sex===1 ? "男" : "女"}},工资{{ money }},身高是{{ height }}cm</div>
            `,
        };
        new Vue({
            el: '#app',
            data: {},
            components: {
                Child,
            }
        });
    </script>
</body>

</html>
```

### 单向数据流

父组件的数据改变了，那么传递给子组件的内容会同步改变  
子组件接收到的 props 的值是不能修改的，如果要改必须在父组件里改  
注意：vue 这里可以改，但会报错（说是不能改，但真能改，会报错），这是设计的错误  
单项数据流， 数据只能 从负的流向子的，字不能改变父的（和子传父不冲突，不是一回事）  
单向数据流，是组件层面的，父组件的东西可以给子组件用，子组件不能去改  
双向数据绑定，组件内部的，组件内部的变量和它的 input 里面的内容可以双向数据绑定  
单向数据流和双向数据绑定是不冲突的，没有任何关系  
vue 是什么数据流？单向数据流

props 的值和 data 一样也会提取到外层  
如果特殊情况真的想改 props 的值，可以将 props 的值作为组件的 data 的初始值  
注意：props 里面的数据和 data 里面的数据不能重名，因为 props 和 data 里面的数据都会向外提取一层  
计算属性可以依赖 props 的值（父组件传入的数据变了，子组件计算属性依赖的 props 的值也会改变，计算属性就会改变）

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 父组件的数据改变了，那么传递给子组件的内容会同步改变 -->
        <!-- 子组件接收到的props的值是不能修改的，如果要改必须在父组件里改 -->
        <!-- 注意：vue这里可以改，但会报错（说是不能改，但真能改，会报错），这是设计的错误 -->
        <!-- 单项数据流， 数据只能 从负的流向子的，字不能改变父的（和子传父不冲突，不是一回事） -->
        <!-- 单向数据流，是组件层面的，父组件的东西可以给子组件用，子组件不能去改 -->
        <!-- 双向数据绑定，组件内部的，组件内部的变量和它的input里面的内容可以双向数据绑定 -->
        <!-- 单向数据流和双向数据绑定是不冲突的，没有任何关系 -->
        <!-- vue是什么数据流？单向数据流 -->

        <h3>单向数据流-<button @click="count++">点击</button></h3>
        <child :count="count"></child>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        const child = {
            props: {
                count: Number,
            },
            // props的值和data一样也会提取到外层
            template: `
                <div>child组件-{{ this.count }}-{{ num }}-{{ doubleCount }}-<button @click="num++">点击</button></div>
            `,
            // 如果特殊情况真的想改props的值，可以将props的值作为组件的data的初始值
            // 注意：props里面的数据和data里面的数据不能重名，因为props和data里面的数据都会向外提取一层
            data() {
                return {
                    num: this.count,
                };
            },
            // 计算属性可以依赖props的值（父组件传入的数据变了，子组件计算属性依赖的props的值也会改变，计算属性就会改变）
            computed: {
                doubleCount() {
                    return this.count * 2;
                },
            },
            mounted() {
                console.log(this.count);
            },
        }
        new Vue({
            el: '#app',
            data: {
                count: 10,
            },
            components: {
                child,
            }
        });
    </script>
</body>

</html>
```

### 子传父($emit 调用)

先在子组件里面去调用父组件的自定义事件

1. 需要在父组件的子组件标签上面添加自定义事件，（自定义事件的事件处理函数写在父组件的 methods 里面）
2. 在子组件里面使用 this.$emit()方法进行调用  
this.$emit()方法可以接受多个参数，第一个参数是父组件里面子组件标签上的自定义事件名称，从第二个参数开始就是子组件要传给父组件的变量（响应式数据），如果变量过多可以采用对象的形式进行传参

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <h3>父组件{{ fatherMsg }}</h3>
        <child @abc="handleAbc"></child>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        // 子传父
        // 先在子组件里面去调用父组件的自定义事件
        // 1.需要在父组件的子组件标签上面添加自定义事件，（自定义事件的事件处理函数写在父组件的methods里面）
        // 2.在子组件里面使用this.$emit()方法进行调用
        //this.$emit()方法可以接受多个参数，第一个参数是父组件里面子组件标签上的自定义事件名称，从第二个参数开始就是子组件要传给父组件的变量（响应式数据），如果变量过多可以采用对象的形式进行传参
        Vue.component('child', {
            data() {
                return {
                    msg: 'hello vue!',
                };
            },
            template: `
                <div>child组件{{ msg }}
                    <button @click="handleClick">点击的时候调用</button>
                </div>
            `,
            // 组件挂后调用
            // mounted() {
            //     this.$emit('abc');
            // }
            methods: {
                handleClick() {
                    // 这里可以传多个参数，第一个参数是父组件里面子组件上面自定义的事件名称，第二个参数就是子组件要传给父组件的数据，如果数据比较多，可以采用对象的形式传参
                    this.$emit("abc", this.msg);
                }
            }
        })


        new Vue({
            el: '#app',
            data: {
                fatherMsg: '',
            },
            methods: {
                handleAbc(msg) {
                    // console.log(1,);
                    this.fatherMsg = msg;
                }
            }
        });
    </script>
</body>

</html>
```

### 组件添加 v-model

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <h3>组件添加v-model</h3>
        <p>{{ msg }}</p>
        <!-- 改写前 -->
        <!-- <child :value="msg" @input="handleAbc"></child> -->
        <!-- v-model改写后 -->
        <!-- v-mode就是v-bind和v-on的语法糖 -->
        <child v-model="msg"></child>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        // 父组件的变量和子组件的input的内容做双向绑定
        Vue.component('child', {
            props: ["value"],
            template: `
                <input type="text" :value="value" @input="handleInput">
            `,
            methods: {
                handleInput(e) {
                    // console.log(e.target.value);
                    this.$emit("input", e.target.value);
                }
            }
        })


        new Vue({
            el: '#app',
            data: {
                msg: "hello vue!",
            },
            // 换成v-mode后就不需要了
            // methods: {
            //     handleAbc(value) {
            //         this.msg = value;
            //     }
            // }
        });
    </script>
</body>

</html>
```

### 动态组件(`<component />` is 属性)

vue 提供的组件, 需要配合 is 属性, is 里面写的是组件名称  
动态组件在切换的时候，是会被销毁和重新渲染的

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 这种方法比较蠢 -->
        <!-- <button @click="show=1">按钮1</button>
        <button @click="show=2">按钮2</button>
        <button @click="show=3">按钮3</button>
        <child1 v-if="show===1"></child1>
        <child2 v-if="show===2"></child2>
        <child3 v-if="show===3"></child3> -->

        <hr>

        <button @click="show='child1'">按钮1</button>
        <button @click="show='child2'">按钮2</button>
        <button @click="show='child3'">按钮3</button>

        <!-- vue提供的组件, 需要配合is属性, is里面写的是组件名称 -->
         <!-- 动态组件在切换的时候，是会被销毁和重新渲染的 -->
        <component :is="show"></component>

    </div>

    <script src="../../Vue.js"></script>
    <script>
        Vue.component('child1', {
            template: `
                <div>child1组件</div>
            `,
        });
        Vue.component('child2', {
            template: `
                <div>child2组件</div>
            `,
        });
        Vue.component('child3', {
            template: `
                <div>child3组件</div>
            `,
        });
        new Vue({
            el: '#app',
            data: {
                // show: 1,
                show: "child1",
            }
        });
    </script>
</body>

</html>
```

### 缓存组件(`<keep-alive />`)

vue 提供的组件,keep-alive 是叫缓存组件, 当组件进行切换的时候，不会被销毁和重新创建

动态组件（问题）  
我刚进来时，vue 只渲染显示的组件，其他的组件不会渲染  
当我点击某个组件时，它会对这个组件进行渲染，当我离开的时候，它会自动销毁,里面的定时器还在运行
当我再次点击上一个组件的时候，这个组件又重新渲染，里面的数据又重新加载，又开了一个定时器

解决  
vue 提供了一个`<keep-alive></keep-alive>`组件(keep-alive 的意思是保持生机)，也叫缓存组件  
当组件进行切换的时候，不会被销毁和重新创建

应用（猫眼电影手机端）  
我现在点击一个页面查看页面内容，会有数据请请求，并且我现在把页面往下滚动了
当我切换到另一个页面时，另一个页面在做数据请求，上一个页面组件会被销毁，再次点击的时候再次创建  
我现在又回到第一个页面，可以不用去数据请求数据（组件不会被销毁重新创建），并且还保持在我上一次查看的地方（滚动的地方），这样可以提高用户体验感  
前提条件是需要使用`<keep-alive></keep-alive>`缓存组件，当组件进行切换的时候，不会被销毁和重新创建

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 这种方法比较蠢 -->
        <!-- <button @click="show=1">按钮1</button>
        <button @click="show=2">按钮2</button>
        <button @click="show=3">按钮3</button>
        <child1 v-if="show===1"></child1>
        <child2 v-if="show===2"></child2>
        <child3 v-if="show===3"></child3> -->

        <hr>

        <button @click="show='child1'">按钮1</button>
        <button @click="show='child2'">按钮2</button>
        <button @click="show='child3'">按钮3</button>

        <!-- 动态组件（问题）
        我刚进来时，vue只渲染显示的组件，其他的组件不会渲染
        当我点击某个组件时，它会对这个组件进行渲染，当我离开的时候，它会自动销毁,里面的定时器还在运行
        当我再次点击上一个组件的时候，这个组件又重新渲染，里面的数据又重新加载，又开了一个定时器

        解决
        vue提供了一个<keep-alive></keep-alive>组件(keep-alive的意思是保持生机)，也叫缓存组件
        当组件进行切换的时候，不会被销毁和重新创建
            -->

        <!-- 应用（猫眼电影手机端）
        我现在点击一个页面查看页面内容，会有数据请请求，并且我现在把页面往下滚动了
        当我切换到另一个页面时，另一个页面在做数据请求，上一个页面组件会被销毁，再次点击的时候再次创建
        我现在又回到第一个页面，可以不用去数据请求数据（组件不会被销毁重新创建），并且还保持在我上一次查看的地方（滚动的地方），这样可以提高用户体验感
        前提条件是需要使用<keep-alive></keep-alive>缓存组件，当组件进行切换的时候，不会被销毁和重新创建 -->


        <!-- vue提供的组件, 需要配合is属性, is里面写的是组件名称 -->
        <!-- keep-alive是叫缓存组件, 当组件进行切换的时候，不会被销毁和重新创建 -->
        <keep-alive>
            <component :is="show"></component>
        </keep-alive>

    </div>

    <script src="../../Vue.js"></script>
    <script>
        Vue.component('child1', {
            template: `
                <div>child1组件</div>
            `,
            mounted() {
                console.log('child2 mounted');
            },
            beforeDestroy() {
                console.log('child2 destroy');
            }
        });
        Vue.component('child2', {
            template: `
                <div>child2组件</div>
            `,
        });



        Vue.component('child3', {
            data() {
                return {
                    count: 0,
                }
            },
            template: `
                <div>child3组件-{{ count }}</div>
            `,

            mounted() {
                console.log('child3 mounted');
                setInterval(() => {
                    this.count++;
                }, 1000);
            },
            beforeDestroy() {
                console.log('child3 destroy');
            }
        });
        new Vue({
            el: '#app',
            // vue是以组件为单位进行开发的
            // 组件一般按功能进行划分，最少一个功能
            // 根组件里面的data选项对象也可以写成函数返回对象的形式
            data() {
                return {
                    // show: 1,
                    show: "child1",
                }
            }
        });
    </script>
</body>

</html>
```

### 缓存组件(activated,deactivated)

解决上面的问题（切换的时候关闭定时器，再次回来的时候开启定时器）  
这里需要添加两个生命周期钩子 activated 和 deactivated  
activated 钩子：被 keep-alive 缓存的组件激活时调用。该钩子在服务器端渲染期间不被调用。  
deactivated 钩子：被 keep-alive 缓存的组件失活时调用。该钩子在服务器端渲染期间不被调用

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 这种方法比较蠢 -->
        <!-- <button @click="show=1">按钮1</button>
        <button @click="show=2">按钮2</button>
        <button @click="show=3">按钮3</button>
        <child1 v-if="show===1"></child1>
        <child2 v-if="show===2"></child2>
        <child3 v-if="show===3"></child3> -->

        <hr>

        <button @click="show='child1'">按钮1</button>
        <button @click="show='child2'">按钮2</button>
        <button @click="show='child3'">按钮3</button>

        <!-- 动态组件（问题）
        我刚进来时，vue只渲染显示的组件，其他的组件不会渲染
        当我点击某个组件时，它会对这个组件进行渲染，当我离开的时候，它会自动销毁,里面的定时器还在运行
        当我再次点击上一个组件的时候，这个组件又重新渲染，里面的数据又重新加载，又开了一个定时器

        解决
        vue提供了一个<keep-alive></keep-alive alive>组件(keep-alive的意思是保持生机)，也叫缓存组件
        当组件进行切换的时候，不会被销毁和重新创建
            -->

        <!-- 应用（猫眼电影手机端）
        我现在点击一个页面查看页面内容，会有数据请请求，并且我现在把页面往下滚动了
        当我切换到另一个页面时，另一个页面在做数据请求，上一个页面组件会被销毁，再次点击的时候再次创建
        我现在又回到第一个页面，可以不用去数据请求数据（组件不会被销毁重新创建），并且还保持在我上一次查看的地方（滚动的地方），这样可以提高用户体验感
        前提条件是需要使用<keep-alive></keep-alive>缓存组件，当组件进行切换的时候，不会被销毁和重新创建 -->


        <!-- vue提供的组件, 需要配合is属性, is里面写的是组件名称 -->
        <!-- keep-alive是叫缓存组件, 当组件进行切换的时候，不会被销毁和重新创建 -->
        <keep-alive>
            <component :is="show"></component>
        </keep-alive>

    </div>

    <script src="../../Vue.js"></script>
    <script>
        Vue.component('child1', {
            template: `
                <div>child1组件</div>
            `,
            mounted() {
                console.log('child2 mounted');
            },
            beforeDestroy() {
                console.log('child2 destroy');
            }
        });
        Vue.component('child2', {
            template: `
                <div>child2组件</div>
            `,
        });


        let timer;
        Vue.component('child3', {
            data() {
                return {
                    count: 0,
                }
            },
            template: `
                <div>child3组件-{{ count }}</div>
            `,

            mounted() {
                console.log('child3 mounted');
                // timer = setInterval(() => {
                //     this.count++;
                // }, 1000);
            },
            beforeDestroy() {
                console.log('child3 destroy');
                clearInterval(timer); //在动态组件里这里的定时器并没有被销毁
            },

            // 解决上面的问题（切换的时候关闭定时器，再次回来的时候开启定时器）
            // 这里需要添加两个生命周期钩子activated和deactivated
            // activated钩子：被 keep-alive 缓存的组件激活时调用。该钩子在服务器端渲染期间不被调用。
            // deactivated钩子：被 keep-alive 缓存的组件失活时调用。该钩子在服务器端渲染期间不被调用。

            activated() {
                // console.log('child3 activated');//测试
                timer = setInterval(() => { //激活时开启定时器
                    this.count++;
                }, 1000);
            },
            deactivated() {
                // console.log('child3 deactivated');//测试
                clearInterval(timer); //失活时关闭定时器
            }


        });
        new Vue({
            el: '#app',
            // vue是以组件为单位进行开发的
            // 组件一般按功能进行划分，最少一个功能
            // 根组件里面的data选项对象也可以写成函数返回对象的形式
            data() {
                return {
                    // show: 1,
                    show: "child1",
                }
            }
        });
    </script>
</body>

</html>
```

### 轮播图案例

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .container {
            width: 590px;
            height: 470px;
            border: 1px solid #000;
            margin: 50px auto;
            position: relative;
            overflow: hidden;
        }

        ul {
            height: 470px;
            display: flex;
        }

        .trans {
            transition: all, .5s;
        }

        S li {
            width: 590px;
            height: 470px;
        }

        img {
            width: 100%;
            height: 100%;
        }

        .left {
            position: absolute;
            top: 200px;
            left: 10px;
            font-size: 40px;
            color: #fff;
            cursor: pointer;
        }

        .right {
            position: absolute;
            top: 200px;
            right: 10px;
            font-size: 40px;
            color: #fff;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="app">
        <div class="container" @mouseover="handleMouseover" @mouseout="handleMouseout">
            <ul :class="{trans:hasTrans}" :style="{width:imgList.length*590+'px',transform:'translateX(' + -590 * position + 'px)'}">
                <li v-for="(item,index) in imgList" :key="index">
                    <img :src="item" alt="">
                </li>
            </ul>
            <div class="right" @click="rightClick" :style="{display:show}">></div>
            <div class="left" @click="leftClick" :style="{display:show}">
                </div>
            </div>
        </div>

        <script src="../../Vue.js"></script>
        <script>
            let timer;
            // 表示动画结束了
            let done = true;
            new Vue({
                el: '#app',
                data: {
                    imgList: [
                        "https://img10.360buyimg.com/pop/s1180x940_jfs/t1/120663/13/26116/74210/623d5962E7bf94043/9b29fea79c5a9a43.jpg.webp",
                        "https://imgcps.jd.com/ling4/100026667880/5Lqs6YCJ5aW96LSn/5L2g5YC85b6X5oul5pyJ/p-5f3a47329785549f6bc7a6f2/ae642516/cr/s/q.jpg",
                        "https://img14.360buyimg.com/pop/s1180x940_jfs/t1/107362/20/24177/90602/6233decdE5627d944/b7194e538e3c8c7a.jpg.webp",
                        "https://imgcps.jd.com/img-cubic/creative_server_cia/v2/2000366/100003813734/FocusFullshop/CkRqZnMvdDEvMTc0MDUxLzE1LzE4NjUxLzQwNTY2MS82MGU2OTI4YkVmYTZkMDZmOC9iZWZkOTMzN2QyOWNhM2NlLnBuZxIJMy10eV8wXzU0MAI47ot6QhwKGOS4reS8n-WNlei6q-WFrOWvk-WutuWFtxAAQhMKD-WunuaDoOS5kOS4jeWBnBABQhAKDOeri-WNs-aKoui0rRACQgoKBuS8mOi0qBAHWOayxMX0Ag/cr/s/q.jpg",
                        "https://img10.360buyimg.com/pop/s1180x940_jfs/t1/120663/13/26116/74210/623d5962E7bf94043/9b29fea79c5a9a43.jpg.webp",
                    ],
                    // 向左平移几张，ul的位置
                    position: 0,
                    hasTrans: true,
                    show: 'none',
                },
                // mounted() {
                //     timer = setInterval(() => {
                //         this.rightClick();
                //     }, 2000);
                // },
                methods: {
                    rightClick() {
                        // if (this.position < this.imgList.length - 1) {
                        //     this.position++;
                        // } else {
                        //     this.position = 0;
                        // }
                        if (done) {
                            done = false;
                            this.hasTrans = true;
                            this.position++;
                            if (this.position === this.imgList.length - 1) {
                                setTimeout(() => {
                                    this.hasTrans = false;
                                    this.position = 0;
                                }, 400);
                            };
                            setTimeout(() => {
                                done = true;
                            });
                        }
                    },
                    leftClick() {
                        if (this.position > 0) {
                            this.position--;
                        } else {
                            this.position = this.imgList.length - 1;
                        }
                    },
                    // 鼠标移入
                    handleMouseover() {
                        this.show = 'block';
                        // clearInterval(timer);
                    },
                    // 鼠标移出
                    handleMouseout() {
                        this.show = 'none';
                        // timer = setInterval(() => {
                        //     this.rightClick();
                        // }, 2000);
                    }
                },
            });
        </script>
</body>

</html>
```

### 模板的注意事项

option/tr/td 不能作为组件的根元素的

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <select name="" id="">
            <option-item></option-item>
            <option-item></option-item>
            <option-item></option-item>
        </select>
        <li-item></li-item>

    </div>

    <script src="../../Vue.js"></script>
    <script>
        // option/tr/td不能作为组件的根元素的
        Vue.component('option-item', {
            template: `
                <option>男</option>
            `,
        });
        Vue.component('li-item', {
            template: `
                <li>男</li>
            `,
        });
        new Vue({
            el: '#app',
            data: {}
        });
    </script>
</body>

</html>
```

## 插槽

### 插槽(`<slot />`)

插槽的作用：内容分发

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <h3>插槽</h3>
        <child>123</child>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        // 插槽的作用：内容分发
        // 前后都可以插
        Vue.component('child', {
            template: `
                <div>child组件-<slot></slot></div>
            `,
        })
        new Vue({
            el: '#app',
            data: {}
        });
    </script>
</body>

</html>
```

### 插槽(可以父传子)

插槽不仅可以插入文本，还可以插入元素甚至组件  
插槽的内容用的是父组件的作用域  
父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。  
哪个组件的 template,就用那个组件的作用域

```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- 插槽不仅可以插入文本，还可以插入元素甚至组件 -->
    <!-- 插槽的内容用的是父组件的作用域 -->
    <!-- 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 -->
    <!-- 哪个组件的template,就用那个组件的作用域 -->
    <div id="app">
      <h3>插槽</h3>
      <child>{{ count }}</child>
    </div>

    <script src="../../Vue.js"></script>
    <script>
      const Child = {
        template: `
          <div>child组件 - <slot></slot></div>
        `,
      };

      new Vue({
        el: "#app",
        data() {
          return {
            count: 10,
          };
        },
        components: {
          Child,
        },
      });
    </script>
  </body>
</html>

```

### 插槽的后背内容(默认值)

slot 标签中间写的内容会作为插槽的默认内容

```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <h3>插槽的后备内容</h3>
      <child></child>
    </div>

    <script src="../../Vue.js"></script>
    <script>
      // slot标签中间写的内容会作为插槽的默认内容
      const Child = {
        template: `
          <div>child组件 - <slot>666</slot></div>
        `,
      };

      new Vue({
        el: "#app",
        data: {},
        components: {
          Child,
        },
      });
    </script>
  </body>
</html>

```

### 具名插槽(`v-slot` template name 属性)

具名插槽的作用时：可以让我们想插哪里就插哪里  
具名插槽使用 v-slot:指令，后面是冒号，冒号后面跟一个自定义的名字  
同时 slot 标签里也要加一个 name 的属性，属性名就是上面的自定义名字  
v-slot:可以简写成#

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 具名插槽的作用时：可以让我们想插哪里就插哪里 -->
        <!-- 具名插槽使用v-slot:指令，后面是冒号，冒号后面跟一个自定义的名字 -->
        <!-- 同时slot标签里也要加一个name的属性，属性名就是上面的自定义名字 -->
        <!-- v-slot:可以简写成# -->
        <h3>具名插槽</h3>
        <child>
            <!-- <span>123</span>
            <span>456</span> -->
            <template v-slot:left>
                <span>123</span>
            </template>
            <template v-slot:right>
                <span>456</span>
            </template>
            <!-- <span>789</span>
            <span>888</span> -->
            <!-- 下面的写法等同于上面的写法（上面注释的） -->
            <template v-slot:default>
                <span>789</span>
                <span>888</span>
            </template>
        </child>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        const Child = {
            template: `
                <div><slot name="left"></slot>-child组件-<slot name="right"></slot>-<slot></slot></div>
            `,
        }
        new Vue({
            el: '#app',
            data: {},
            components: {
                Child,
            }
        });
    </script>
</body>

</html>
```

### 作用域插槽(可以子传父)

在子组件中 template 中通过自定义属性的方式传递，在父组件的子组件标签上通过`v-slot:default="slotProps"`接收

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <h3>作用域插槽</h3>
        <!-- count默认是父组件的作用域 -->
        <!-- 作用域插槽就是想在这里使用子组件的作用域 -->
        <child>
            <template v-slot:default="slotProps">
                <span>{{ slotProps.count }}</span>
                <!-- 解构写法 -->
                <!-- <template v-slot:default="{ count }>
                        <span>{{ count }}</span> -->
            </template>
        </child>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        const Child = {
            data() {
                return {
                    count: 10,
                }
            },
            template: `
                <div>child组件-<slot :count="count"></slot></div>
            `,
        }
        new Vue({
            el: '#app',
            data: {},
            components: {
                Child,
            },
        });
    </script>
</body>

</html>
```

## 生命周期

红色部分是我们做的  
蓝色部分是 vue 做的  
![](https://v2.cn.vuejs.org/images/lifecycle.png)

放在 data 里面的东西是有响应式的,可以将没在 html 中使用的数据放在外层  
template 相当于 outerHTML(替换所有的内容，包括标签)

10 种生命周期  
生命周期执行顺序和书写顺序无关  
只有创建阶段和挂载阶段的生命周期会自动执行（只要 new Vue 实例化，前面两个阶段就会自动执行）

### 1.创建阶段（初始化阶段）

1. 在创建之前 vue 自己去初始化了事件和生命周期（vue 做的）
2. beforeCreate() {},————不能去做数据请求，不能拿到 data 里面的响应式数据，不能去做赋值
3. vue 自己初始化了注入和响应式(data 和 methods) （vue 做的）
4. created() {},————这里可以做数据请求，可以拿到响应式数据，可以去做赋值

5. vue 会去检查是否有 el 选项，如果没有 el 选项，vue 就会中断执行(但是可以补救一下，就是在 vm 对象后面链式操作加上.$mount(el)) （vue 做的）

6. vue 会去检查是否有 template 选项（如果有就会用模板替换之前的内容，如果没有就会用 el 里面的元素进行渲染） （vue 做的）

### 2.挂载阶段

7. beforeMount() {},————这里也可以做数据请求
8. 重点注意：**vue 会去将虚拟 dom 替换成真实 dom(将带双大括号的内容渲染成真正的内容)**（vue 做的）
9. mounted() {},————这里可以做数据请求，一般在这 created 和 mounted 里做数据请求

在挂载完成后需要手动销毁组件 this.$destroy(); //手动销毁组件（写在 mounted 里面）  
vue 里面销毁组件是销毁的是响应式

created，beforeMount，mounted 理论上可以请求数据，一般在 mounted 里请求

### 3.更新阶段

更新阶段会在 data 的数据发生改变的时候触发  
**更新前和更新后不是数据改变的前后, 是 dom 重新渲染的前后**  
注意：**数据的改变和页面的渲染不是一起发生的**  
10. beforeUpdate() {},————在 beforeUpdate 可以修改数据，但是一般也不会在这里修改数据  
11. **这里 vue 自己会对更新后的虚拟 dom 进行从重新渲染**（vue 做的）  
12. updated() {},————在 updated 里面不要去修改数据，如果修改数据会造成死循环

### 4.销毁阶段

组件销毁的时候会触发  
组件销毁的时候，组件的定时器是不会被销毁的  
13. beforeDestroy() {},————清除定时器/WebScoket/js 的事件监听/第三方插件的监听  
14. 卸载操作（vue 做的）  
15. destroyed() {},————destroyed 这个生命周期几乎不用

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>生命周期</title>
</head>

<body>
    <div id="app">
        <h3>{{ title }}</h3>
        <p>{{ count }}</p>
        <button @click="count++">点击</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        // 放在data里面的东西是有响应式的
        // timer没有出现在html中,就没有必要放在data里面,放在data里面反而会影响性能
        let timer;

        const ym = new Vue({
            // el: '#app',
            data: { //data里的数据是具有响应式的，data里面的数据会有监听
                title: '生命周期',
                count: 0,
                // timer: null,
            },

            methods: {
                fn() {},
            },

            //template相当于outerHTML(替换所有的内容，包括标签)
            // template: `
            //     <div>123</div>
            // `,


            //生命周期执行顺序和书写顺序无关
            //只有创建阶段和挂载阶段的生命周期会自动执行

            //在创建之前vue自己去初始化了事件和生命周期
            // 1.创建阶段
            beforeCreate() {
                // 不能去做数据请求，不能拿到data里面的响应式数据，不能去做赋值
                console.log('beforeCreate', this.title, this.fn); //beforeCreate undefined undefined
            },
            //vue自己初始化了注入和响应式(data和methods)
            created() {
                //这里可以做数据请求，可以拿到响应式数据，可以去做赋值
                console.log('created', this.title, this.fn); //created 生命周期 ƒ fn() {}
            },


            //vue会去检查是否有el选项//如果没有el选项，就中断执行(但是可以补救一下，就是在vm对象后面链式操作加上.$mount(el))
            // vue会去检查是否有template选项（如果有就会用模板替换之前的内容，如果没有就会用el里面的元素进行渲染）


            // 2.挂载阶段
            beforeMount() {
                //这里也可以做数据请求
                console.log('beforeMount', document.querySelector('#app'));
            },
            //重点注意：vue会去将虚拟dom替换成真实dom(将带双大括号的内容渲染成真正的内容)
            mounted() {
                //这里可以做数据请求，一般在这created和mounted里做数据请求
                console.log('mounted', document.querySelector('#app'));
                //模拟数据请求（因为数据请求是异步的，所以模拟用定时器，定时器也是异步的）
                // setTimeout(() => {
                //     this.count = 10;
                // }, 2000);

                // 测试定时器是否被销毁
                timer = setInterval(() => {
                    console.log(1);
                }, 1000);

                //手动销毁组件
                //vue里面销毁组件是销毁的是响应式
                setTimeout(() => {
                    this.$destroy(); //手动销毁组件
                }, 5000);
            },




            // 3.更新阶段
            // 更新阶段会在data的数据发生改变的时候触发
            // 更新前和更新后不是数据改变的前后, 是dom重新渲染的前后
            // 注意：数据的改变和页面的渲染不是一起发生的

            beforeUpdate() {
                console.log('beforeUpdate', this.count, document.querySelector('p').innerHTML); //beforeUpdate 1 0
                // this.count++;//这里可以修改数据，但是一般也不会在这里修改数据
            },
            //这里vue自己会对更新后的虚拟dom进行从重新渲染
            //在updataed里面不要去修改数据，如果修改数据会造成死循环
            updated() {
                console.log('updated', this.count, document.querySelector('p').innerHTML); //beforeUpdate 1 1
                // this.count++;//不能在updataed里修改数据，会造成死循环
            },



            // 4.销毁阶段
            // 组件销毁的时候会触发
            // 组件销毁的时候，组件的定时器是不会被销毁的
            beforeDestroy() {
                //清除定时器/WebScoket/js的事件监听/第三方插件的监听
                console.log('beforeDestroy');
                clearInterval(timer); //销毁组件中的定时器
            },
            //destroyed这个生命周期几乎不用
            destroyed() {
                console.log('destroyed');
            },
        }).$mount('#app');
    </script>
</body>

</html>
```

## 添加样式

### class(对象语法)

`<p :class="className">hello vue!</p>`  
`<p :class="big ? 'big' : 'small'">hello vue</p>`  
在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组  
如果使用对象，key 表示类名，value 表示表达式  
如果类名有连字符，需要加一个引号  
class 和:class 是可以一起使用的  
`<p :class="{ big:big,'red-color':active===1 }" class="abc">hello vue!</p>`

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .big {
            font-size: 50px;
        }

        .small {
            font-size: 20px;
        }

        .red-color {
            color: red;
        }
    </style>
</head>

<body>
    <div id="app">
        <!-- <p :class="className">hello vue!</p> -->
        <!-- 三目不好识别 -->
        <!-- <p :class="big ? 'big':'small'">hello vue!</p> -->

        <!-- 在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组 -->
        <!-- 如果使用对象，key表示类名，value表示表达式 -->
        <!-- 如果类名有连字符，需要加一个引号 -->
        <!-- class和:class是可以一起使用的 -->
        <p :class="{ big:big,'red-color':active===1 }" class="abc">hello vue!</p>
        <button @click="active=2">点击</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                className: 'big',
                big: true,
                active: 1,
            }
        });
    </script>
</body>

</html>
```

### class 练习

```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .active {
        background-color: red;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <ul>
        <li
          v-for="(item, index) in list"
          :class="{ active: index === activeIndex }"
          @click="activeIndex = index"
        >
          {{ item }}
        </li>
      </ul>
    </div>

    <script src="../../Vue.js"></script>
    <script>
      new Vue({
        el: "#app",
        data: {
          list: [111, 222, 333],
          activeIndex: 0,
        },
      });
    </script>
  </body>
</html>
```

### style(对象语法)

可以使用对象的语法写:style  
key 对应的 css 的属性，value 是变量或者 js 表达式

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>绑定内联样式</title>
</head>

<body>
    <div id="app">
        <!-- <p style="color:red;font-size:50px">hello vue!</p> -->

        <!-- 可以使用对象的语法写:style -->
        <!-- key对应的css的属性，value是变量或者js表达式 -->
        <!-- 点击按钮，实现字体加1，水平移动5 -->
        <button @click="size++,distance+=5">点击</button>
        <p :style="{color:color,'font-size':size+'px',transform:'translateX('+distance+'px)'}">hello vue!</p>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                color: 'red',
                size: 50,
                distance: 0,
            }
        });
    </script>
</body>

</html>
```

## 事件

### 自定义事件

定义：连字符  
调用：连字符

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 自定义事件 -->
        <!-- 定义：连字符 -->
        <!-- 调用：连字符 -->
        <child @get-count="fn"></child>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        const Child = {
            template: `
                <div>child组件</div>
          `,
            mounted() {
                this.$emit("get-count");
            }
        }
        new Vue({
            el: '#app',
            data: {},
            components: {
                Child,
            },
            methods: {
                fn() {
                    console.log('fn');
                }
            }
        });
    </script>
</body>

</html>
```

### 事件修饰符(stop prevent)

.stop 修饰符表示阻止事件冒泡  
.prevent 修饰符用于阻止默认行为

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .father {
            width: 400px;
            height: 400px;
            background-color: green;
        }

        .son {
            width: 200px;
            height: 200px;
            background-color: red;
        }
    </style>
</head>

<body>
    <div id="app">
        <div class="father" @click="fatherClick">
            <!-- .stop修饰符表示阻止事件冒泡 -->
            <div class="son" @click.stop="sonClick"></div>
        </div>

        <!-- .prevent修饰符用于阻止默认行为 -->
        <form action="" @submit.prevent="onSubmit">
            <input type="text">
            <input type="submit">
        </form>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {},
            methods: {
                fatherClick() {
                    console.log('fatherClick');
                },
                sonClick(e) {
                    // event.stopPropagation();
                    console.log('sonClick');
                },
                // form表单提交的时候会有一个默认行为，就是刷新页面
                onSubmit() {
                    console.log(1);
                }
            }
        });
    </script>
</body>

</html>
```

### 按键修饰符(enter 13)

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 两种都可以 -->
        <!-- <input type="text" @keyup.enter="handleClick"> -->
        <input type="text" @keyup.13="handleClick">
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {},
            methods: {
                handleClick(e) {
                    // console.log(e.target.value);
                    // js里的写法
                    // if (e.keyCode === 13) {
                    //     console.log(e.target.value);
                    // }
                    // if (e.key === 'Enter') {
                    //     console.log(e.target.value);
                    // }
                    console.log(e.target.value);
                }
            }
        });
    </script>
</body>

</html>
```

### 表单输入绑定

```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <h2>普通文本框</h2>
      <input v-model="message" placeholder="edit me" />
      <p>Message is: {{ message }}</p>

      <hr />

      <h2>多行文本框</h2>
      <span>Multiline message is:</span>
      <p style="white-space: pre-line">{{ message2 }}</p>
      <br />
      <textarea v-model="message2" placeholder="add multiple lines"></textarea>

      <hr />

      <h2>多选框</h2>
      <!-- 如果这个变量只被一个多选框绑定 -->
      <!-- 绑定的是布尔值 -->
      <input
        type="checkbox"
        id="checkbox"
        v-model="checked"
        true-value="yes"
        false-value="no"
      />
      <label for="checkbox">{{ checked }}</label>

      <br />
      <!-- 如果这个变量只被多个多选框绑定 -->
      <!-- 绑定的是数组 -->
      <input type="checkbox" id="jack" value="Jack" v-model="checkedNames" />
      <label for="jack">Jack</label>
      <input type="checkbox" id="john" value="John" v-model="checkedNames" />
      <label for="john">John</label>
      <input type="checkbox" id="mike" value="Mike" v-model="checkedNames" />
      <label for="mike">Mike</label>
      <br />
      <span>Checked names: {{ checkedNames }}</span>

      <hr />

      <h2>单选框</h2>
      <!-- 单选框绑定的是字符串类型 -->
      <input type="radio" id="one" value="One" v-model="picked" />
      <label for="one">One</label>
      <br />
      <input type="radio" id="two" value="Two" v-model="picked" />
      <label for="two">Two</label>
      <br />
      <span>Picked: {{ picked }}</span>

      <hr />

      <h2>下拉框</h2>
      <!-- 下拉框默认绑定的是字符串类型 -->
      <!-- 如果有multiple属性绑定的是数组类型 -->
      <select v-model="selected">
        <option disabled value="">请选择</option>
        <option value="1">A</option>
        <option value="2">B</option>
        <option value="3">C</option>
      </select>
      <span>Selected: {{ selected }}</span>
    </div>

    <script src="../../Vue.js"></script>
    <script>
      new Vue({
        el: "#app",
        data: {
          message: "",
          message2: "",
          checked: false,
          checkedNames: [],
          picked: "",
          selected: "",
        },
      });
    </script>
  </body>
</html>

```

### 表单修饰符(lazy,number,trim)

lazy 修饰符就是将 onInput 事件换成 onChange 事件  
number 修饰符,将表单的值转成数字类型  
trim 修饰符用于去除首尾空格

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <h2>lazy修饰符</h2>
        <!-- lazy修饰符就是将 onInput事件换成onChange事件 -->
        <input type="text" v-model.lazy="text1">
        <p>{{ text1 }} - {{ typeof text1 }}</p>
        <hr>

        <h2>number修饰符</h2>
        <!-- number类型，只可以输入数字和e -->
        <!-- <input type="number" v-model="text2"> -->
        <!-- number修饰符,将表单的值转成数字类型 -->
        <input type="number" v-model.number="text2">
        <!-- 修饰符可以链式操作 -->
        <!-- <input type="number" v-model.number.lazy="text2"> -->
        <p>{{ text2 }} - {{ typeof text2 }}</p>


        <hr>
        <h2>trim修饰符</h2>
        <!-- trim修饰符用于去除首尾空格 -->
        <input type="text" v-model.trim="text3">
        <p>{{ text3 }}</p>
        <button @click="handleClick">点击</button>
        <hr>

    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                text1: "",
                text2: "",
                text3: "",
            },
            methods: {
                handleClick() {
                    console.log(this.text3);
                }
            }
        });
    </script>
</body>

</html>
```

### 事件补充(native 修饰符)

@click 添加在子组件标签上面，它默认就是自定义事件  
native 修饰符是可以尝试着将自定义事件转成原声事件

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- @click添加在子组件标签上面，它默认就是自定义事件 -->
        <!-- native修饰符是可以尝试着将自定义事件转成原声事件 -->
        <h3>事件补充，native修饰符</h3>
        <child @click.native="handleClick"></child>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        Vue.component('child', {
            template: `
                <div>child组件</div>
            `,
        })
        new Vue({
            el: '#app',
            data: {},
            methods: {
                handleClick() {
                    console.log(1);
                }
            }
        });
    </script>
</body>

</html>
```
