## 基础语法

### vue 实例

引入的 Vue 是一个构造函数，里面可以传入一个选项对象

data 里面的内容会向外放一层，直接挂载到实例下面  
只有当实例被创建时就已经存在于 data 中的 property 才是响应式的  
`Object.freeze()`用来冻结数据的  
只能有一个根元素

```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <p>{{ a }}</p>
      <p>{{ obj }}</p>
      <button v-on:click="handleClick">btn</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
      const data = {
        a: 3,
        obj: {
          x: 10,
          y: 20,
          z: null, // 如果想有响应式，需要设置初始值
        },
      };

      // Object.freeze()用来冻结数据的
      // Object.freeze(data);

      const vm = new Vue({
        // data里面的内容会向外放一层，直接挂载到实例下面
        el: "#app",
        data,
        methods: {
          // 只有当实例被创建时就已经存在于 data 中的 property 才是响应式的
          handleClick() {
            // this.obj.y = 30;
            this.obj.z = 30;   // 如果想有响应式，需要设置初始值
          },
        },
      });
    </script>
  </body>
</html>

```

### 简介

项目的最外层只有一个 div
选项式（选项对象）

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <!-- 项目的最外层只有一个div  -->
    <div id="app">
        <!-- 双大括号的模板语法，可以将响应式数据直接渲染到模板里 -->
        <p>{{ msg }}</p>
        <ul>
            <!-- v-for指令，用于循环渲染，这里相当于for...in -->
            <!-- <li v-for="item in list">{{ item }}</li> -->
            <li v-for="item in productsList">
                {{ item.title }}的库存还剩{{ item.count }}件
                <!-- v-if表示条件渲染 -->
                <span v-if="item.count===0">——卖完了</span>
                <span>，单价{{ item.price }}元——————</span>
                <!-- v-on:click表示单击事件-->
                <button v-on:click="item.count++">+</button>
                <button v-on:click="item.count--">-</button>
                <!-- v-model表示双向数据绑定 -->
                <input type="text" v-model="item.count">
                <input type="text" v-model="item.count*item.price">
            </li>
        </ul>
        <p>总数：{{ total }}</p>
        <p>总价: {{ allPrice }}</p>
    </div>



    <!-- 引入Vue -->
    <script src="../../Vue.js"></script>
    <script>
        //引入的Vue是一个构造函数，里面可以传入一个选项对象
        const vm = new Vue({
            //所有的代码都是写在这个对象里面
            //对象的形式是key和value,key称之为options

            //element,意味着vue要去控制这个元素
            el: '#app',
            // data表示响应式数据
            data: {
                msg: "hello vue!",
                list: ["苹果", "香蕉", "橘子", "西瓜"],
                productsList: [{
                    title: "苹果",
                    count: 5,
                    price: 5
                }, {
                    title: "香蕉",
                    count: 20,
                    price: 6
                }, {
                    title: "橘子",
                    count: 10,
                    price: 7
                }, {
                    title: "西瓜",
                    count: 20,
                    price: 8
                }, ]
            },
            //computed表示计算属性 total(总计的意思)，里面写函数，要有return
            computed: {
                total() {
                    return this.productsList.reduce((sum, item) => {
                        return (sum += +item.count);
                    }, 0);
                },
                allPrice() {
                    return this.productsList.reduce((a, item) => {
                        return (a += (+item.price) * item.count);
                    }, 0);
                },
            },

            //表示渲染结束执行，window.onload
            // mounted() {
            //     setTimeout(() => {
            //         this.msg = 'hi';
            //     }, 3000);
            // },
        })
    </script>
</body>

</html>
```

### 声明式渲染`{{}}`

使用双括号的形式进行声明式的渲染，文本  
用双大括号显示的时候，除了 undefined 和 null 以外，都会一字符串的方式显示  
双大括号里面不仅可以使用变量，还可以使用 js 表达式

属性如果要使用变量或者表达式，使用 v-bind 的指令

data 里面的数据是具有响应式的（当这个数据一旦发生改变，页面就会自动的从新渲染）  
在 Vue 里面所有的操作都是在操作数据（再也没有 dom 操作了），数据驱动

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>声明式渲染</title>
</head>

<body>
    <div id="app">
        <!-- 使用双括号的形式进行声明式的渲染，文本 -->
        <!-- 用双大括号显示的时候，除了undefined和null以外，都会一字符串的方式显示 -->
        <!-- 双大括号里面不仅可以使用变量，还可以使用js表达式 -->
        <p>{{ msg }}</p>
        <p>{{ msg.split("").reverse().join("") }}</p>
        <p>{{ count * 2 }}</p>
        <p>{{ done }}</p>
        <p>{{ !done }}</p>
        <p>{{ unf }}</p>
        <p>{{ nl }}</p>
        <p>{{ arr }}</p>
        <p>{{ obj }}</p>

        <hr>

        <!-- 属性如果要使用变量或者表达式，使用v-bind的指令  属性 -->
        <p v-bind:title="title">hello Vue!</p>
        <p v-bind:title="title+1">hello Vue!</p>
        <img v-bind:src="imgUrl" alt="">

    </div>


    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: "#app", //挂载的元素
            // data里面的数据是具有响应式的（当这个数据一旦发生改变，页面就会自动的从新渲染）
            // 在Vue里面所有的操作都是在操作数据（再也没有dom操作了），数据驱动
            data: { //响应式数据
                msg: "hello Vue!",
                count: 2,
                done: true,
                unf: undefined,
                nl: null,
                arr: [1, 2, 3, 4],
                obj: {
                    a: 1,
                    b: 2,
                    c: 3
                },
                title: 123,
                imgUrl: 'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnimg.ws.126.net%2F%3Furl%3Dhttp%3A%2F%2Fdingyue.ws.126.net%2F2021%2F0428%2F8d1df149j00qs9aa4001dc000hs00fym.jpg%26thumbnail%3D650x2147483647%26quality%3D80%26type%3Djpg&refer=http%3A%2F%2Fnimg.ws.126.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1651052104&t=6292c3e9d4635bae81b26af6e28b8571',
            },
        });
    </script>
    <div title="123">hello</div>
</body>

</html>
```

### template

template 就是空的占位符标签，不会显示  
vue 自己提供的一个组件

### key

用 key 管理可复用的元素  
Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，`<input>` 不会被替换掉——仅仅是替换了它的 placeholder  
给元素添加了不同的 key 值，相当于告诉 vue，这两个元素没有关系，不要进行复用

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 用 key 管理可复用的元素 -->
        <!-- Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<input> 不会被替换掉——仅仅是替换了它的 placeholder。 -->

        <!-- 给元素添加了不同的key值，相当于告诉vue，这两个元素没有关系，不要进行复用 -->
        <template v-if="loginType === 'username'">
          <label>Username</label>
          <input placeholder="Enter your username" key='1'>
        </template>
        <template v-else>
          <label>Email</label>
          <input placeholder="Enter your email address" key='0'>
        </template>

        <hr>

        <button @click="loginType = loginType === 'username' ? '123' : 'username'">点击</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                loginType: "username",
            }
        });
    </script>
</body>

</html>
```

### 条件渲染`v-if`

v-if 用于控制一个元素是否渲染  
v-if 里面可以写变量和表达式

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>条件渲染</title>
</head>

<body>
    <div id="app">
        <p>{{ show }}</p>
        <button v-on:click="show=!show">点击</button>
        <!-- v-if用于控制一个元素是否渲染 -->
        <!-- v-if里面可以写变量和表达式 -->
        <p v-if="show===1">现在你看到我了</p>
    </div>


    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: "#app",
            data: {
                // show: false,
                show: 1,
            }
        })
    </script>
</body>

</html>
```

### `v-else` `v-else-if`

v-if 和 v-else 要是并列的兄弟元素

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <h1 v-if="awesome">Vue is awesome!</h1>
        <!-- v-if和v-else要是并列的兄弟元素 -->
        <h1 v-else>Oh no 😢</h1>

        <!-- template就是空的占位符标签，不会显示 -->
        <!-- vue自己提供的一个组件 -->

        <!-- <div v-if="awesome">111</div>
        <div v-if="awesome">222</div>
        <div v-if="awesome">333</div>
        <div v-if="awesome">444</div> -->

        <!-- 满足v-if指令后面的条件则显示template标签里面的内容，不满足则执行v-else指令里面的内容 -->
        <template v-if="show===1">
        <div>111</div>
        <div>111</div>
        <div>111</div>
        <div>111</div>
        </template>
        <!-- 满足v-else-if指令后面的条件，则执行里面的内容 -->
        <template v-else-if="show===2">
        <div>333</div>
        <div>333</div>
        <div>333</div>
        <div>333</div>
        </template>
        <!-- v-else指令上面两个条件都不满足，则执行里面的内容 -->
        <template v-else>
        <div>222</div>
        <div>222</div>
        <div>222</div>
        <div>222</div>
        </template>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                awesome: true,
                show: 20,
            }
        });
    </script>
</body>

</html>
```

### `v-show`

v-show 的语法和 v-if 完全相同  
show 是通过 css 的 display 属性进行切换  
v-if 如果初始化的时候条件为假，则不会进行渲染，直到条件为真才会进行渲染，v-if 是有惰性的  
v-show 初始化的时候已经被渲染，不管条件的真假，它是通过控制元素的 display 属性进行显示的，条件为真则显示，条件为假就不显示

v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。  
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。  
相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。  
一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。

v-show 不能 template 一起用  
v-show 不能和 v-else 以及 v-else-if 一起用

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- v-show的语法和v-if完全相同 -->
        <!-- 区别在于v-show是通过css的display属性进行切换 -->
        <!-- v-if如果初始化的时候条件为假，则不会进行渲染，直到条件为真才会进行渲染，v-if是有惰性的
             v-show初始化的时候已经被渲染，不管条件的真假，它是通过控制元素的display属性进行显示的，条件为真则显示，条件为假就不显示 -->

        <h1 v-if="awesome">Vue is awesome</h1>
        <button @click="awesome=!awesome">点击</button>

        <h1 v-show="awesome1">Vue is awesome</h1>
        <button @click="awesome1=!awesome1">点击</button>
        <!--
        v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。

        v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

        相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

        一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。
       -->
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                awesome: false,
                awesome1: false,
            }
        });
    </script>
</body>

</html>
```

### 列表渲染`v-for`

哪个元素要循环，就给哪个元素添加 v-for

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>列表渲染</title>
</head>

<body>
    <div id="app">
        <!-- v-for指令用于做循环渲染 -->
        <!-- 哪个元素要循环，就给哪个元素添加v-for -->
        <!-- item表示的是每一项，形参 -->
        <ul>
            <li v-for="value in list">{{ value }}</li>
        </ul>

        <hr>

        <p v-for="item in todos">{{ item.text }}</p>
    </div>



    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: "#app",
            data: {
                list: [1, 2, 3, 4],
                todos: [{
                    text: "你好，html"
                }, {
                    text: "你好，css"
                }, {
                    text: "你好，js"
                }, {
                    text: "你好，vue"
                }, ]
            },
        })
    </script>
</body>

</html>
```

### `v-for`遍历数组和对象

v-for 遍历数组时可以接收二个参数（这里的参数都是形参，自定义的，相当于形参）  
第一个参数是：item(数组中的每一项)  
第二个参数：index（每一项所对应的索引）  
for in 循环也可以写成 for of 循环  
在 vue 里 for...in...和 for...of...一样，都可以遍历数组或者对象

遍历对象  
v-for(in&of)遍历对象时，有三个参数  
第一个参数：属性值（value）  
第二个参数：属性名（key  
第三个参数：索引（index）

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- v-for遍历数组时可以接收二个参数（这里的参数都是形参，自定义的，相当于形参）-->
        <!-- 第一个参数是：item(数组中的每一项)， -->
        <!-- 第二个参数：index（每一项所对应的索引） -->
        <!-- for in 循环也可以写成 for of 循环 -->
        <!-- 在vue里for...in...和for...of...一样，都可以遍历数组或者对象 -->

        <!-- 遍历数组 -->
        <Ul>
            <!-- <li v-for="(item,index) in lists">{{ item.message }}-{{ index }}</li> -->
            <li v-for="(item,index) of lists">{{ item.message }}-{{ index }}</li>
        </Ul>

        <hr>

        <!-- 遍历对象 -->
        <!-- v-for(in&of)遍历对象时，有三个参数 -->
        <!-- 第一个参数：属性值（value） -->
        <!-- 第二个参数：属性名（key）-->
        <!-- 第三个参数：索引（index） -->
        <ul>
            <!-- <li v-for="(value,key,index) in object">{{ value }}----{{ key }}----{{ index }}</li> -->
            <li v-for="(value,key,index) of object">{{ value }}----{{ key }}----{{ index }}</li>
        </ul>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                lists: [{
                    message: "Foo"
                }, {
                    message: "Bar"
                }],
                object: {
                    title: "How to do lists in Vue",
                    author: "Jane Doe",
                    publishedAt: "2016-04-10",
                },
            }
        });
    </script>
</body>

</html>
```

### 循环嵌套，在 v-for 里使用范围值

```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <div v-for="item in sets">
        <div v-for="val in item">{{ val }}</div>
      </div>

      <span v-for="n in 10">{{ n }} </span>

      <div v-for="item in 9">
        <span v-for="value in item">
          {{ value }} * {{ item }} = {{ value * item }}
        </span>
      </div>
    </div>

    <script src="../../Vue.js"></script>
    <script>
      new Vue({
        el: "#app",
        data: {
          sets: [
            [1, 2, 3, 4, 5],
            [6, 7, 8, 9, 10],
          ],
        },
      });
    </script>
  </body>
</html>

```

### v-if 和 v-for 不要一起使用

一个元素同时有 v-for 和 v-if, v-for 会有一个更高的优先级

判断条件和 item 相关的时候，可以使用计算属性来过滤  
判断条件和 item 无关的时候，可以把 v-if 放到父元素

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 一个元素同时有v-for和v-if, v-for会有一个更高的优先级 -->

        <!-- 这种会有性能损耗 -->
        <ul>
            <!-- 判断条件和item相关的时候，可以使用计算属性来过滤 -->
            <li v-for="(item,index) in list" :key="index" v-if="item%2">{{ item }}</li>
        </ul>

        <!-- 利用计算属性，先对数据进行过滤，过滤完之后再进行循环 -->
        <ul>
            <li v-for="(item,index) in oddList" :key="index" v-if="item%2">{{ item }}</li>
        </ul>

        <!-- 这种方法，添加一个show变量，对show进行判断，如果为true就进行循环，如果为false则不会进行循环 -->
        <ul>
            <li v-for="(item,index) in newList" :key="index">{{ item }}</li>
        </ul>

        <!-- 判断条件和item无关的时候，可以把v-if放到父元素 -->
        <ul v-if="show">
            <li v-for="(item,index) in list" :key="index">{{ item }}</li>
        </ul>


    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                list: [1, 2, 3, 4, 5, 6, 7],
                show: true,
            },
            computed: {
                oddList() {
                    return this.list.filter(item => item % 2);
                },
                newList() {
                    if (this.show) {
                        return this.list;
                    } else {
                        return [];
                    }
                }
            },
        });
    </script>
</body>

</html>
```

### 循环中的 key

key 保证如果改变前后的两个元素的 key 是相同的，就会直接复用，提高性能  
key 必须保证不重复, key 必须是数字或者字符串  
只要使用 v-for 循环，就必须加:key=""（无脑加）,最好的用 id,如果没有 id 才用 index
key 的值不可以是引用类型（复杂类型）的，因为引用类型比较的是地址，改变前和改变后对象的值地址肯定是不相同的，

vue 在使用 v-for 循环的时候，如果我们要在数组或者对象中添加或者修改内容，vue 会从新进行渲染（卸载和重新创建），其实我们只是在原数组或者对象中添加一项，前面的几项还是一样的，但是 vue 也会重新渲染（卸载并重新创建），这样就会造成性能损耗，浪费资源。因此我们需要在循环的元素中添加一个 key（key 必选保证不重复，同时 key 必须是数字或者字符串），渲染的每一个元素的 key 都是不相同的，这样可以让 vue 进行判断，如果再次渲染和渲染前元素的 key 相同，就不会进行渲染就可以复用，只会渲染 key 值不相同的元素，可以提升性能

尽量不要使用 index 作为 key，实在没办法才使用 index 作为 key(因为如果在数组中插入一项，那么原有的数组项的 index 会改变，key 值就不相同了，vue 就无法进行复用，只能重新卸卸载并创建)

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- key保证如果改变前后的两个元素的key是相同的，就会直接复用，提高性能 -->
        <!-- key必须保证不重复, key必须是数字或者字符串 -->
        <!-- 只要使用v-for循环，就必须加:key=""（无脑加）,最好的用id,如果没有id才用index-->
        <!-- key的值不可以是引用类型（复杂类型）的，因为引用类型比较的是地址，改变前和改变后对象的值地址肯定是不相同的， -->
        <!-- vue在使用v-for循环的时候，如果我们要在数组或者对象中添加或者修改内容，vue会从新进行渲染（卸载和重新创建），其实我们只是在原数组或者对象中添加一项，前面的几项还是一样的，但是vue也会重新渲染（卸载并重新创建），这样就会造成性能损耗，浪费资源。因此我们需要在循环的元素中添加一个key（key必选保证不重复，同时key必须是数字或者字符串），渲染的每一个元素的key都是不相同的，这样可以让vue进行判断，如果再次渲染和渲染前元素的key相同，就不会进行渲染就可以复用，只会渲染key值不相同的元素，可以提升性能 -->

        <!-- 尽量不要使用index作为key，实在没办法才使用index作为key(因为如果在数组中插入一项，那么原有的数组项的index会改变，key值就不相同了，vue就无法进行复用，只能重新卸卸载并创建) -->
        <ul>
            <li v-for="(item,index) in list" :key="item.id">{{ item.message }}</li>
        </ul>
        <button @click="fn">点击</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                list: [{
                    message: "Foo",
                    id: 1
                }, {
                    message: "Bar",
                    id: 2
                }, ],
                arr: [1, 2, 3, 3, 3],
            },
            methods: {
                fn() {
                    this.list.push({
                        message: 'zoo',
                        id: 3,
                    });
                },
            },
        });
    </script>
</body>

</html>
```

### 数组的检测更新

#### 响应式失效

1. 直接改变数组长度
2. 通过索引去改变数组项
3. 在对象里面挂载新属性

解决(依靠 es5 的浅拷贝，将原来的数组的长度变为 3，通过扩展运算符展开这个数组，放入一个新数组，重新赋值给这个数组，利用的是浅拷贝)

`...` `concat` `Object.assign`

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <ul>
            <li v-for="(item,index) in list" :key="index">{{ item }}</li>
        </ul>
        <p>{{ obj }}</p>
        <button @click="handleClick">点击</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                list: [1, 2, 3, 4, 5],
                obj: {
                    a: 3,
                    b: 4,
                },
            },
            methods: {
                handleClick() {
                    // this.list.push(6);
                    //响应式失效
                    // 1. 直接改变数组长度
                    // 2. 通过索引去改变数组项
                    // 3. 在对象里面挂载新属性

                    this.list.length = 3; //响应式失效
                    // this.list[2] = 20;//响应式失效
                    // this.obj.a = 10;//正常
                    this.obj.c = 100; //响应式失效

                    // 解决(依靠es5的浅拷贝，将原来的数组的长度变为3，通过扩展运算符展开这个数组，放入一个新数组，重新赋值给这个数组，利用的是浅拷贝)
                    //方法1
                    this.list = [...this.list];
                    // this.list[2]=20;
                    // console.log(this.list);
                    //方法2
                    this.list = [].concat(this.list);
                    //方法1
                    // this.obj = {...this.obj
                    // };
                    //方法2
                    this.obj = Object.assign({}, this.obj);
                },
            },
        });
    </script>
</body>

</html>
```

### 事件`v-on`

调用事件处理函数时，小括号可以加，也可以不加  
加上括号可以做事件的传参  
如果只获取事件对象，不传实参，不用加括号，否则就获取不到事件对象（会输出 undefined）  
如果需要传参，同时需要获取事件对象，则把事件对象写在后面$event

v-on 可以缩写成@

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>事件</title>
</head>

<body>
    <div id="app">
        <!-- v-on指令用于定义事件 -->
        <button v-on:click="handleClick">点击1</button>
        <hr>
        <p>{{ count }}</p>
        <!-- <button v-on:click="count++">count++</button> -->
        <!-- 调用事件处理函数时，小括号可以加，也可以不加 -->
        <!-- 加上括号可以做事件的传参 -->
        <!-- 如果只获取事件对象，不传实参，不用加括号，否则就获取不到事件对象（会输出undefined） -->
        <button v-on:click="countAdd(2)">点击+2</button>
        <button v-on:click="countAdd(3)">点击+3</button>
        <hr>
        <!-- 如果需要传参，同时需要获取事件对象，则把事件对象写在后面$event -->
        <button v-on:click="fn()">点击2</button>
        <button v-on:click="fn2(3,$event)">点击3</button>
        <hr>
        <input type="text" v-on:input="handleInput">
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: "#app",
            data: {
                count: 1,
            },
            // methods选项就是定义事件处理函数的地方
            methods: {
                handleClick() {
                    console.log(1);
                },
                countAdd(num) {
                    this.count += num;
                },
                fn(e) {
                    console.log(e); //undefined 打印事件对象
                },
                fn2(num, e) {
                    console.log(num);
                    console.log(e);
                },
                handleInput(e) {
                    console.log("input的值改变了");
                    console.log(e.target);
                    console.log(e.target.value);
                }
            },
        })
    </script>
</body>

</html>
```

### 双向绑定`v-model`

双向绑定必须是和表单元素相关的  
v-model 指令可以用于双向数据绑定，input 和 data 里面的响应式数据进行绑定  
v-model 只是一个语法糖 v-model 加在 input 中  
v-model 其实就是 v-bind 和 v-on 的语法糖

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>双向绑定</title>
</head>

<body>
    <div id="app">
        <!-- 双向绑定必须是和表单元素相关的 -->
        <!-- v-model指令可以用于双向数据绑定，input和data里面的响应式数据进行绑定 -->
        <!-- v-model只是一个语法糖 v-model加在input中 -->
        <!-- v-model其实就是v-bind和v-on的语法糖 -->

        <input type="text" v-model="msg">
        <p>{{ msg }}</p>
        <button v-on:click="handleClick">点击</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: "#app",
            data: {
                msg: 'hello vue',
            },
            methods: {
                handleClick() {
                    this.msg = 'hi';
                },
            },
        });
    </script>
</body>

</html>
```

### 双向绑定(手动实现)

v-model 其实就是 v-bind 和 v-on 的语法糖

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>手动实现</title>
</head>

<body>
    <div id="app">
        <!-- v-model其实就是v-bind和v-on的语法糖 -->
        <input type="text" v-bind:value="msg" v-on:input="handleInput">
        <p>{{ msg }}</p>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                msg: 'hello vue',
            },

            methods: {
                handleInput(e) {
                    this.msg = e.target.value;
                },
            },
        });
    </script>
</body>

</html>
```

### TODOLIST 案例

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>发布案例</title>
</head>

<body>
    <div id="app">
        <input type="text" v-model="textValue">
        <button v-on:click="add">添加</button>

        <ul>
            <li v-for="value in list">{{ value }}————
                <button v-on:click="remove(value)">删除</button>
            </li>
        </ul>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: "#app",
            data: {
                list: ['你好，世界', '你好,html'],
                textValue: "",
            },
            methods: {
                add() {
                    this.list.push(this.textValue);
                    this.textValue = "";
                },
                remove(v) {
                    this.list = this.list.filter(value => value !== v);
                    // this.list = this.list.filter((value) => {
                    //     return value !== v;
                    // });
                },
            },
        });
    </script>
</body>

</html>
```

## 模板语法

### 插值`v-once`

v-once 指令表示这个元素只会被渲染一次

### 原始 HTML`v-html`

v-html 指令可以将内容转成 html 标签进行渲染

### 原始普通文本`v-text`

v-text 指令和双大括号一样渲染普通文本

### 属性`v-bind`

v-bind 指令可以将数据绑定到属性上，缩写成：

```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <h3>模板语法</h3>
      <!-- v-once指令表示这个元素只会被渲染一次 -->
      <p v-once>{{ count }}</p>
      <p>{{ count }}</p>
      <button @click="count++">btn</button>

      <hr />

      <!-- v-html指令可以将内容转成html标签进行渲染 -->
      <div>{{ content }}</div>
      <div v-html="content"></div>
      <!-- v-text指令和双大括号一样渲染普通文本 -->
      <div v-text="content"></div>

      <hr />

{/* 动态参数 */}
      <img :[str]="imgUrl" alt="" />
    </div>

    <script src="../../Vue.js"></script>
    <script>
      new Vue({
        el: "#app",
        data: {
          count: 1,
          content: "<h1>标题</h1>",
          str: "data-src",
          imgUrl:
            "https://img2.baidu.com/it/u=839977396,1548112407&fm=253&fmt=auto&app=138&f=JPEG?w=554&h=500",
        },
        mounted() {
          setTimeout(() => {
            this.str = "src";
          }, 2000);
        },
      });
    </script>
  </body>
</html>

```

## 计算属性(computed)

计算属性(看似是个函数，可以把他当做属性看)  
里面写的是函数，里面的函数必须要有返回值  
计算属性是不改变原始数据的（就是 data 里面的响应式数据），原始数据还是原样，可以使用  
计算属性是有缓存的，缓存的是函数的返回值，只有当依赖发生改变的时候才会再次计算  
计算属性需要有依赖，响应式数据就是它的依赖  
计算属性里面的函数一开始就会先执行（计算属性里面的函数只要有依赖，它就会先执行好，然后存储下来，函数所依赖的响应式数据只要发生改变，计算属性就会从新计算，并从新保存,用的时候当做属性使用，不用去调用）  
一个计算属性可以同时依赖多个响应式数据，还可以依赖其它的计算属性  
不能直接修改计算属性，改变计算属性唯一的方式就是修改它的依赖（依赖的响应式数据）

计算属性什么时候使用  
我们要通过现有的响应式数据，计算出或者说过滤出一个新的值的时候，并且要不改变响应式数据，可以使用计算属性

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- <p>{{ msg.split("").reverse().join("") }}</p>
        <p>{{ msg.split("").reverse().join("") }}</p>
        <p>{{ msg.split("").reverse().join("") }}</p> -->

        <!-- <p>{{ reverseMsg() }}</p>
        <p>{{ reverseMsg() }}</p>
        <p>{{ reverseMsg() }}</p> -->

        <p>{{ msg }}</p>
        <p>{{ reverseMsg }}</p>
        <p>{{ reverseMsg }}</p>
        <p>{{ reverseMsg }}</p>
        <button @click="handleClick">点击</button>

        <ul>
            <li v-for="item in doubleOddArr">{{ item }}</li>
        </ul>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                msg: 'hello vue!',
                count: 5,
                arr: [1, 2, 3, 4, 5, 6],
            },
            methods: {
                // reverseMsg() {
                //     console.log(1);
                //     return this.msg.split("").reverse().join("");
                // },
                handleClick() {
                    this.msg = this.msg + 5;
                    this.arr.push(7);
                    this.reverseMsg = 'hi'; //报错  不能直接修改计算属性
                }
            },
            //计算属性(看似是个函数，可以把他当做属性看)
            //里面写的是函数，里面的函数必须要有返回值
            // 计算属性是不改变原始数据的（就是data里面的响应式数据），原始数据还是原样，可以使用
            //计算属性是有缓存的，缓存的是函数的返回值，只有当依赖发生改变的时候才会再次计算
            //计算属性需要有依赖，响应式数据就是它的依赖
            //计算属性里面的函数一开始就会先执行（计算属性里面的函数只要有依赖，它就会先执行好，然后存储下来，函数所依赖的响应式数据只要发生改变，计算属性就会从新计算，并从新保存,用的时候当做属性使用，不用去调用）
            // 一个计算属性可以同时依赖多个响应式数据，还可以依赖其它的计算属性
            // 不能直接修改计算属性，改变计算属性唯一的方式就是修改它的依赖（依赖的响应式数据）

            // 计算属性什么时候使用
            // 我们要通过现有的响应式数据，计算出或者说过滤出一个新的值的时候，并且要不改变响应式数据，可以使用计算属性
            computed: {
                reverseMsg() {
                    console.log(1);
                    return this.msg.split("").reverse().join("") + this.count; //一个计算属性可以同时依赖多个响应式数据
                },
                oddArr() {
                    return this.arr.filter(item => item % 2 === 1);
                },
                doubleOddArr() {
                    return [...this.oddArr, ...this.oddArr]; //还可以依赖其它的计算属性
                },
            }
        });
    </script>
</body>

</html>
```

## 侦听属性(watch)

监听响应式数据，里面写函数，函数的名称就是要监听的响应式数据（也就是变量）

监听对象

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <p>{{ count }}</p>
        <button @click="count++">点击</button>

        <hr>

        <p>{{ obj.a }}</p>
        <button @click="obj.a=40">点击</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                count: 1,
                obj: {
                    a: 4,
                    b: 5,
                },
            },
            //watch用于监听
            // 监听响应式数据，里面写函数，函数的名称就是要监听的响应式数据（也就是变量）
            watch: {
                //监听count这个变量
                count(val, oldVal) { //val:新值  oldVal:旧值
                    console.log(1);
                    console.log(val);
                    console.log(oldVal);
                },
                //监听obj这个对象
                // obj(val) {
                //     console.log(val); //打印不出来结果，因为obj是引用类型的数据，监听的是地址，只要地址不发生改变，旧监听不到，而我们要监听的是obj对象里面的a的值，所以不能这样写
                // },
                obj: {
                    handler(val) {
                        console.log(val);
                    },
                    // 深度监听，可以监听对象和数组
                    deep: true,
                    // 进入页面的时候就会先做一次监听
                    immediate: true,
                },

            }
        });
    </script>
</body>

</html>
```

## 计算属性 vs 侦听属性

计算属性是依赖的响应式数据发生改变的时候执行，得到一个新的值（被动），这个属性会在模板中使用的  
侦听属性是自己的这个变量改变了，从而去触发这个函数（主动）  
计算属性可以同时依赖多个响应式数据，还可以依赖其它的计算属性，侦听属性只能一个一个去侦听  
一般情况下更加推荐使用计算属性  
当执行异步或开销较大的操作时，使用 watch

```javascript

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <input type="text" v-model="firstName">
        <br>
        <input type="text" v-model="lastName">
        <br>
        <p>{{ fullName }}</p>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                firstName: '李',
                lastName: '四',
                fullName: '李 四',
            },
            // 监听属性实现
            watch: {
                firstName(val) {
                    this.fullName = val + '' + this.lastName;
                },
                lastName(val) {
                    this.fullName = this.firstName + '' + val;
                },
            },
            // 计算属性实现
            // computed: {
            //     fullName() {
            //         return this.firstName + '' + this.lastName;
            //     },
            // },
        });
    </script>

</body>

</html>
```

## 组件

创建组件有两种方式

- 全局组件
- 局部组件

### 全局组件

里面有两个参数，第一个参数是组件名称，第二个参数是选项对象  
这个对象里面写的是 option，new Vue 可以写什么，这里就可以写什么，除了 el  
里面必须要有一个东西叫 template

#### 组件的取名规则

- 顾名思义(语义化)
- 不能和现有的 h5 标签重复
- 取名要使用连字符或者大驼峰
- 使用的时候要使用连字符

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>组件</title>
</head>

<body>
    <div id="app">
        <tbheader></tbheader>
        <tbheader></tbheader>

        <tbbody></tbbody>
        <tbbody></tbbody>
        <tbbody></tbbody>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        //创建组件有两种方式

        //全局创建组件
        //里面有两个参数，第一个参数是组件名称，第二个参数是选项对象
        Vue.component('tbheader', {
            // 这个对象里面写的是option，new Vue可以写什么，这里就可以写什么，除了el
            // 里面必须要有一个东西叫template
            template: '<header>淘宝头部</header>'
        });

        Vue.component('tbbody', {
            // 组件里面的data要使用函数的方式
            data() {
                return {
                    count: 123,
                };
            },
            template: `
                <main>{{ count }}</main>
            `,
        })

        /*
        组件的取名规则
          顾名思义(语义化)
          不能和现有的h5标签重复
          取名要使用连字符或者大驼峰
          使用的时候要使用连字符
      */
        new Vue({
            el: "#app",
        })
    </script>
</body>

</html>
```

### 局部组件

对象里面写的还是选项，跟全局创建组件的第二个参数完全相同  
取名只能使用大驼峰了,使用只能用连字符  
局部创建的组件是需要注册的(在 components 中)

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <tb-header></tb-header>
        <tb-footer></tb-footer>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        // 局部创建组件
        // 对象里面写的还是选项，跟全局创建组件的第二个参数完全相同

        // 取名只能使用大驼峰了,使用只能用连字符
        const TbHeader = {
            template: `<div>淘宝头部</div>`,
        };
        const TbButton = {
            template: `<button>按钮</button>`,
        };

        //组件的嵌套
        const TbFooter = {
            data() {
                return {
                    msg: '底部',
                };
            },
            template: `<footer>淘宝{{ msg }}---<tb-button></tb-button></footer>`,
            components: {
                TbButton,
            }
        }


        new Vue({
            el: '#app',
            data: {},
            //局部创建的组件是需要注册的
            components: {
                TbHeader,
                TbFooter,
            }
        });
    </script>
</body>

</html>
```

## 生命周期

红色部分是我们做的  
蓝色部分是 vue 做的  
![](https://v2.cn.vuejs.org/images/lifecycle.png)

放在 data 里面的东西是有响应式的,可以将没在 html 中使用的数据放在外层  
template 相当于 outerHTML(替换所有的内容，包括标签)

10 种生命周期  
生命周期执行顺序和书写顺序无关  
只有创建阶段和挂载阶段的生命周期会自动执行（只要 new Vue 实例化，前面两个阶段就会自动执行）

### 1.创建阶段（初始化阶段）

1. 在创建之前 vue 自己去初始化了事件和生命周期（vue 做的）
2. beforeCreate() {},————不能去做数据请求，不能拿到 data 里面的响应式数据，不能去做赋值
3. vue 自己初始化了注入和响应式(data 和 methods) （vue 做的）
4. created() {},————这里可以做数据请求，可以拿到响应式数据，可以去做赋值

5. vue 会去检查是否有 el 选项，如果没有 el 选项，vue 就会中断执行(但是可以补救一下，就是在 vm 对象后面链式操作加上.$mount(el)) （vue 做的）

6. vue 会去检查是否有 template 选项（如果有就会用模板替换之前的内容，如果没有就会用 el 里面的元素进行渲染） （vue 做的）

### 2.挂载阶段

7. beforeMount() {},————这里也可以做数据请求
8. 重点注意：**vue 会去将虚拟 dom 替换成真实 dom(将带双大括号的内容渲染成真正的内容)**（vue 做的）
9. mounted() {},————这里可以做数据请求，一般在这 created 和 mounted 里做数据请求

在挂载完成后需要手动销毁组件 this.$destroy(); //手动销毁组件（写在 mounted 里面）  
vue 里面销毁组件是销毁的是响应式

created，beforeMount，mounted 理论上可以请求数据，一般在 mounted 里请求

### 3.更新阶段

更新阶段会在 data 的数据发生改变的时候触发  
**更新前和更新后不是数据改变的前后, 是 dom 重新渲染的前后**  
注意：**数据的改变和页面的渲染不是一起发生的**  
10. beforeUpdate() {},————在 beforeUpdate 可以修改数据，但是一般也不会在这里修改数据  
11. **这里 vue 自己会对更新后的虚拟 dom 进行从重新渲染**（vue 做的）  
12. updated() {},————在 updated 里面不要去修改数据，如果修改数据会造成死循环

### 4.销毁阶段

组件销毁的时候会触发  
组件销毁的时候，组件的定时器是不会被销毁的  
13. beforeDestroy() {},————清除定时器/WebScoket/js 的事件监听/第三方插件的监听  
14. 卸载操作（vue 做的）  
15. destroyed() {},————destroyed 这个生命周期几乎不用

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>生命周期</title>
</head>

<body>
    <div id="app">
        <h3>{{ title }}</h3>
        <p>{{ count }}</p>
        <button @click="count++">点击</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        // 放在data里面的东西是有响应式的
        // timer没有出现在html中,就没有必要放在data里面,放在data里面反而会影响性能
        let timer;

        const ym = new Vue({
            // el: '#app',
            data: { //data里的数据是具有响应式的，data里面的数据会有监听
                title: '生命周期',
                count: 0,
                // timer: null,
            },

            methods: {
                fn() {},
            },

            //template相当于outerHTML(替换所有的内容，包括标签)
            // template: `
            //     <div>123</div>
            // `,


            //生命周期执行顺序和书写顺序无关
            //只有创建阶段和挂载阶段的生命周期会自动执行

            //在创建之前vue自己去初始化了事件和生命周期
            // 1.创建阶段
            beforeCreate() {
                // 不能去做数据请求，不能拿到data里面的响应式数据，不能去做赋值
                console.log('beforeCreate', this.title, this.fn); //beforeCreate undefined undefined
            },
            //vue自己初始化了注入和响应式(data和methods)
            created() {
                //这里可以做数据请求，可以拿到响应式数据，可以去做赋值
                console.log('created', this.title, this.fn); //created 生命周期 ƒ fn() {}
            },


            //vue会去检查是否有el选项//如果没有el选项，就中断执行(但是可以补救一下，就是在vm对象后面链式操作加上.$mount(el))
            // vue会去检查是否有template选项（如果有就会用模板替换之前的内容，如果没有就会用el里面的元素进行渲染）


            // 2.挂载阶段
            beforeMount() {
                //这里也可以做数据请求
                console.log('beforeMount', document.querySelector('#app'));
            },
            //重点注意：vue会去将虚拟dom替换成真实dom(将带双大括号的内容渲染成真正的内容)
            mounted() {
                //这里可以做数据请求，一般在这created和mounted里做数据请求
                console.log('mounted', document.querySelector('#app'));
                //模拟数据请求（因为数据请求是异步的，所以模拟用定时器，定时器也是异步的）
                // setTimeout(() => {
                //     this.count = 10;
                // }, 2000);

                // 测试定时器是否被销毁
                timer = setInterval(() => {
                    console.log(1);
                }, 1000);

                //手动销毁组件
                //vue里面销毁组件是销毁的是响应式
                setTimeout(() => {
                    this.$destroy(); //手动销毁组件
                }, 5000);
            },




            // 3.更新阶段
            // 更新阶段会在data的数据发生改变的时候触发
            // 更新前和更新后不是数据改变的前后, 是dom重新渲染的前后
            // 注意：数据的改变和页面的渲染不是一起发生的

            beforeUpdate() {
                console.log('beforeUpdate', this.count, document.querySelector('p').innerHTML); //beforeUpdate 1 0
                // this.count++;//这里可以修改数据，但是一般也不会在这里修改数据
            },
            //这里vue自己会对更新后的虚拟dom进行从重新渲染
            //在updataed里面不要去修改数据，如果修改数据会造成死循环
            updated() {
                console.log('updated', this.count, document.querySelector('p').innerHTML); //beforeUpdate 1 1
                // this.count++;//不能在updataed里修改数据，会造成死循环
            },



            // 4.销毁阶段
            // 组件销毁的时候会触发
            // 组件销毁的时候，组件的定时器是不会被销毁的
            beforeDestroy() {
                //清除定时器/WebScoket/js的事件监听/第三方插件的监听
                console.log('beforeDestroy');
                clearInterval(timer); //销毁组件中的定时器
            },
            //destroyed这个生命周期几乎不用
            destroyed() {
                console.log('destroyed');
            },
        }).$mount('#app');
    </script>
</body>

</html>
```

## 添加样式

### class

`<p :class="className">hello vue!</p>`  
`<p :class="big ? 'big' : 'small'">hello vue</p>`  
在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组  
如果使用对象，key 表示类名，value 表示表达式  
如果类名有连字符，需要加一个引号  
class 和:class 是可以一起使用的  
`<p :class="{ big:big,'red-color':active===1 }" class="abc">hello vue!</p>`

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .big {
            font-size: 50px;
        }

        .small {
            font-size: 20px;
        }

        .red-color {
            color: red;
        }
    </style>
</head>

<body>
    <div id="app">
        <!-- <p :class="className">hello vue!</p> -->
        <!-- 三目不好识别 -->
        <!-- <p :class="big ? 'big':'small'">hello vue!</p> -->

        <!-- 在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组 -->
        <!-- 如果使用对象，key表示类名，value表示表达式 -->
        <!-- 如果类名有连字符，需要加一个引号 -->
        <!-- class和:class是可以一起使用的 -->
        <p :class="{ big:big,'red-color':active===1 }" class="abc">hello vue!</p>
        <button @click="active=2">点击</button>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                className: 'big',
                big: true,
                active: 1,
            }
        });
    </script>
</body>

</html>
```

### class 练习

```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .active {
        background-color: red;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <ul>
        <li
          v-for="(item, index) in list"
          :class="{ active: index === activeIndex }"
          @click="activeIndex = index"
        >
          {{ item }}
        </li>
      </ul>
    </div>

    <script src="../../Vue.js"></script>
    <script>
      new Vue({
        el: "#app",
        data: {
          list: [111, 222, 333],
          activeIndex: 0,
        },
      });
    </script>
  </body>
</html>
```

### style

可以使用对象的语法写:style  
key 对应的 css 的属性，value 是变量或者 js 表达式

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>绑定内联样式</title>
</head>

<body>
    <div id="app">
        <!-- <p style="color:red;font-size:50px">hello vue!</p> -->

        <!-- 可以使用对象的语法写:style -->
        <!-- key对应的css的属性，value是变量或者js表达式 -->
        <!-- 点击按钮，实现字体加1，水平移动5 -->
        <button @click="size++,distance+=5">点击</button>
        <p :style="{color:color,'font-size':size+'px',transform:'translateX('+distance+'px)'}">hello vue!</p>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                color: 'red',
                size: 50,
                distance: 0,
            }
        });
    </script>
</body>

</html>
```

## 事件

### 事件修饰符

.stop 修饰符表示阻止事件冒泡  
.prevent 修饰符用于阻止默认行为

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .father {
            width: 400px;
            height: 400px;
            background-color: green;
        }

        .son {
            width: 200px;
            height: 200px;
            background-color: red;
        }
    </style>
</head>

<body>
    <div id="app">
        <div class="father" @click="fatherClick">
            <!-- .stop修饰符表示阻止事件冒泡 -->
            <div class="son" @click.stop="sonClick"></div>
        </div>

        <!-- .prevent修饰符用于阻止默认行为 -->
        <form action="" @submit.prevent="onSubmit">
            <input type="text">
            <input type="submit">
        </form>
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {},
            methods: {
                fatherClick() {
                    console.log('fatherClick');
                },
                sonClick(e) {
                    // event.stopPropagation();
                    console.log('sonClick');
                },
                // form表单提交的时候会有一个默认行为，就是刷新页面
                onSubmit() {
                    console.log(1);
                }
            }
        });
    </script>
</body>

</html>
```

### 按键修饰符

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 两种都可以 -->
        <!-- <input type="text" @keyup.enter="handleClick"> -->
        <input type="text" @keyup.13="handleClick">
    </div>

    <script src="../../Vue.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {},
            methods: {
                handleClick(e) {
                    // console.log(e.target.value);
                    // js里的写法
                    // if (e.keyCode === 13) {
                    //     console.log(e.target.value);
                    // }
                    // if (e.key === 'Enter') {
                    //     console.log(e.target.value);
                    // }
                    console.log(e.target.value);
                }
            }
        });
    </script>
</body>

</html>
```
