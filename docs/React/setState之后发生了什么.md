setState 方法用于修改 state  
setState 方法可以接收两个参数，同时又两种写法  
第一个参数可以是对象或者回调函数，第二个参数是回调函数，回调函数中可以拿到修改后的值  
如果说要依赖前一次的值，使用回调函数，不依赖前一次的值，使用对象

```jsx
this.setState({ },()=>{ }).                                                                       .
this.setState( (prevState)=>{ } , ()=>{ } )
```

setState 是异步的  
在 react17 版本之前  
在合成事件和生命周期中是异步的，在定时器和原生 js 事件中是同步的  
在 react18 版本之后全部都是异步的

**React 会将当前传入的对象与组件当前的状态合并**,

1. setState 是同步还是异步？  
   **执⾏过程代码同步的，只是合成事件和钩⼦函数的调⽤顺序在更新之前，导致在合成事件和钩⼦函数中没法⽴马拿到更新后的值**，形成了所谓的“异步”，所以表现出来有时是同步，有时是“异步”。
2. 何时是同步，何时是异步呢？  
   只在合成事件和钩⼦函数中是“异步”的，在原⽣事件和 setTimeout/ setInterval 等原⽣ API 中都是同步的。简单的可以理解为被 React 控制的函数⾥⾯就会表现出“异步”，反之表现为同步。
3. 那为什么会出现异步的情况呢？  
   **为了做性能优化，将 state 的更新延缓到最后批量合并再去渲染对于应⽤的性能优化是有极⼤好处的，如果每次的状态改变都去重新渲染真实 dom，那么它将带来巨⼤的性能消耗**。
4. 那如何在表现出异步的函数⾥可以准确拿到更新后的 state 呢？  
   通过第⼆个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。

每次 setState 的时候就会重新渲染一次 dom，为了减少不必要的渲染，提供了一个优化，用异步的方法把这些想要渲染的值全部压到最后，压到最后**批量更新** state 的值，只引发了一次 dom 渲染，如果是同步的话，更新一个，立马就去渲染 dom，太浪费性能

setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。
