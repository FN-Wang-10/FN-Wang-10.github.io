## diff 算法的基本流程

第一次 render 在执行的时候会将第一次的虚拟 dom 做一次缓存，第二次渲染的时候会将新的虚拟 dom 和老的虚拟 dom 进行对比。这个对比的过程其实就是 diff 算法。

1. 层级比较——对应 vue 的同级比较，没有跨层级移动，所以可以同级比较
2. 组件对比——组件能复用就直接复用（将时间复杂度从 on 的三次方，降到 on 的一次方）
3. 节点对比——对应 vue 的 key 的比较  
   虚拟 dom，diff 算法，要能用自己的话说出来

## diff 算法的作用（提高性能）

在 DOM 需要更新的时候，通过 diff 算法可以 计算出 虚拟 DOM 中真正变化的部分，从而只针对变化的部分进行更新渲染，避免造成性能浪费。

## 普通的 diff 算法

虽然完美地实现了找不同的功能，但是傻瓜式的循环递归对节点进行依次的对比，使其算法的时间复杂度为 O(n^3)，其中 n 是 dom 树的节点数。如果 dom 数足够大的话，这个算法将对 cpu 形成绝杀。

## React 中的 diff 算法

为了优化 diff 算法，react 中对普通的 diff 算法实行了三大策略，成功将时间复杂度降为 O(n )
策略一：tree diff —— 层级对比 （对应 vue 的同级比较，没有跨层级移动，所以可以同级比较）  
 由于开发过程中极少出现 DOM 的跨层级移动，所以 tree diff 忽略了 DOM 节点的跨层级移动。（react 不建议开发人员跨层级移动 DOM）  
策略二：component diff —— 组件对比 （组件能复用就直接复用（将时间复杂度从 on 的三次方，降到 on 的一次方）  
 同类型的两个组件，直接比较 Virtual DOM 树，不同类型的组件将会被判定作为脏组件(dirty component)处理，直接删除或创建新组件  
策略三：element diff —— 节点对比 （对应 vue 的 key 的比较）  
 对于同一层级的一组子节点，通过分配唯一唯一 key 值进行区分

### tree 层级

1.  对跨层级的 dom 节点操作不做优化，只会对相同层级的节点进行比较
2.  只有删除和创建操作，没有移动操作

### component 层级

如果是同一个类的组件，则会继续往下 diff 运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的

### element 层级

1.  对于比较同一层级的节点们，每个节点在对应的层级用唯一的 key 作为标识
2.  提供了 3 种节点操作，分别为 INSERT_MARKUP(插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)
3.  通过 key 可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置
