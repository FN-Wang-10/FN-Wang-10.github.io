在 react 16 之后发布的一种 react 核心算法  
例：一个非常大的任务需要 2s 中执行，可以将它分成 10 个小任务，每一个任务 200ms,200ms 一个任务的总时长还是 2s 左右，影响不太大，当第一个小任务执行完时，有时间去执行其他的东西了  
例：星巴克  
去买星巴克，前面站了一个人，他要 100 杯，按照逻辑，我需要等待他的 100 杯全部做好才轮到我，我就需要等待特别久  
（为了不让后面的消费者等待很长的时间，现在有一个办法）  
现在店主可以给他 10 杯 10 杯的做，做 10 个 10 杯，店主先给他做 10 杯，然后问后面的人，有没有需要一杯两杯的，如果有的话，做完第一个 10 杯后，给后面的需要的少的顾客先做，然后再给他做 10 杯，然后再问后面的人...在做 10 杯....直到 100 杯做完  
这样对后面的顾客来说就不需要等待很长的时间了，对需要 100 杯的顾客来说可能世家会稍长一点

React Fiber 的方法其实很简单——**分片**。把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。

webkit v8  
问题  
JavaScript 引擎和页面渲染引擎两个线程是互斥的，当其中一个线程执行时，另一个线程只能挂起等待  
如果 JavaScript 线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待，界面长时间不更新，会导致页面响应度变差，用户可能会感觉到卡顿  
而这也正是 React 15 的 Stack Reconciler 所面临的问题，当 React 在渲染组件时，从开始到渲染完成整个过程是一气呵成的，无法中断  
如果组件较大，那么 js 线程会一直执行，然后等到整棵 VDOM 树计算完成后，才会交给渲染的线程  
这就会导致一些用户交互、动画等任务无法立即得到处理，导致卡顿的情况
